---
title: "TFM"
subtitle: ""
author: "Cristina Muntañola Valero"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true 
    toc_depth: 3
    df_print: paged
  html_document:
    toc: true
    toc_depth: 3
    df_print: paged
urlcolor: blue
---

En esta parte se pretende explicar todo el proceso de análsis usado para el estudio. A modo explicativo, se han ido comentando cada paso y por qué se han realizado.
 
# Tipos de datos

Primeramente buscamos en la web de geo (https://www.ncbi.nlm.nih.gov/geo/query) lo que necesitamos. Buscamos cada nombre de los GSE de la tabla https://docs.google.com/presentation/d/1KbodurM_1zFzuMJi3B6CgYvRo7bddDIZeJ5SqcdhNMM/edit#slide=id.gf901ec2662_0_1 dentro de la web. En la parte de abajo de la página, nos descargamos cada archivo GSE. Descomprimimos cada GSE, y encontramos lo siguiente dentro de cada uno y en la web:

-GSE8879: archivos .CEL. Perfil de expresión génica de T-ALL atípica. Extracción de linfoblastos de niños en el momento del diagnóstico. Uso de array U133A de Affymetrix. Última fecha de actualización 2018, EE.UU.

-GSE10609: archivos .CEL. Perfiles de expresión por array. Estudio de un subgrupo de T-ALL. 67 pacientes, 92 muestras. Array de Affymetrix Human Genome U133 Plus 2.0. Última fecha de actualización 2019, Países Bajos.

-GSE14618: archivos .CEL. Generación de perfiles de expresión por matriz. Chip Affymetrix U133 Plus 2.0. 50 niños recién diagnosticados. Última fecha de actualización 2019, EE.UU.

-GSE26713: archivos .CEL. Generación de perfiles de expresión por matriz, se identificaron dos subtipos de T-ALL. Chip Affymetrix U133 Plus 2.0. 117 muestras de pacientes pediátricos. Última fecha de actualización 2019, Países Bajos.

-GSE28703: archivos .CEL. Generación de perfiles de expresión por matriz, T-ALL temprana (ETP ALL). Affymetrix HT HG-U133+ PM Array Plate. Secuenciación de genoma de ADN tumoral y normal, 12 niños con ETP-ALL, 52 ETP con tumores y 42 muestras de T-ALL no ETP. Última fecha de actualización 2018, EE.UU.

-GSE32215: archivos .CEL. T-ALL. Array Affymetrix Human Genome U133 Plus 2.0. 228 muestras de T-ALL, con 117 muestras reanálisis de GSE26713. Última fecha de actualización 2019, Países Bajos.

-GSE33469: archivos .txt de los GPL. Generación de perfiles de expresión por array. Illumina HumanHT-12 V4.0 expression beadchip. 57 muestras de T-ALL de adultos. Última fecha de actualización 2018, EE.UU.

-GSE33470: archivos .txt de los GPL. Perfil de expresión de poblaciones de timocitos. 3 pacientes pediátricos (de 7 días a 6 meses de edad, es decir, 7 poblaciones de células T). Illumina HumanHT-12 V4.0 expression beadchip. Última fecha de actualización 2018, EE.UU.

-GSE37389: archivos .txt de los GSM. Generación de perfiles de expresión por array. Agilent-014850 Whole Human Genome Microarray 4x44K G4112F. Última fecha de actualización 2019,	India.

-GSE56488: archivos .CEL y .txt de los GPL. Generación de perfiles de expresión por array. Affymetrix Human Gene 2.0 ST Array. Muestras de T-ALL. Última fecha de actualización 2015, Francia.

-GSE62156: archivos .CEL. Generación de perfiles de expresión por array. Affymetrix Human Genome U133 Plus 2.0 Array. 64 muestras de T-ALL. Última fecha de actualización 2019, Bélgica.

-GSE110633: archivos .tab de los GSM. Generación de perfiles de expresión por array. Cohorte primaria de pacientes con T-ALL. Illumina NextSeq 500. Última fecha de actualización 2019, Bélgica.


-GSE110636: archivos .tab de los GSM. Generación de perfiles de expresión por array. Cohorte primaria de pacientes con T-ALL. Illumina NextSeq 500. Última fecha de actualización 2020, Bélgica.

# Introducción y tipos depreparación de datos

Vamos a introducir las bases de datos descargadas. Definiremos el directorio.

```{r, message=FALSE, echo=TRUE}
require(Biobase)
datadir <- "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/"
```

Dentro de la carpeta datasets del directorio mencionado, se hace un guardado de distintos archivos de R. En esos archivos se define el procedimiento para leer los archivos .txt y .tab, y luego guardarlos como xlsx.

# Importado de datos

Lo podemos hacer así si nos los descargams de GEO:

files = list.files("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE8879/",full.names = TRUE)

library(affy)
affy.data = ReadAffy(filenames = files[3:94])

length(affy.data@assayData[["exprs"]])

-----------
O así sin descargar desde la página:

library(GEOquery)
gse <- getGEO("GSE8879", GSEMatrix = TRUE)

---------
El procedimiento que vamos a seguir es algo común...

# GSE8879


```{r, message=FALSE, echo=TRUE, warning=FALSE}
require(Biobase)
datadir <- "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/"
```


```{r, message=FALSE, echo=TRUE}
library(GEOquery)
GSE8879_getGEO <- getGEO("GSE8879", GSEMatrix =TRUE, AnnotGPL=TRUE,destdir = "datasets/GSE8879/" )
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
getGEOSuppFiles ("GSE8879") ## Descargar datos sin procesar
setwd("datasets/GSE8879/") ## Ingresa al directorio de descarga
dir() ## Ver el contenido del archivo
untar("GSE8879_RAW.tar") ## Descomprime el archivo
archivos<- dir(pattern = "gz$") ## Cargar archivos
sapply(archivos, gunzip) ## Fusionar archivos
filelist<-list.files("datasets/GSE8879/", pattern =  ".CEL$")
```


## Unificar el procesamiento de archivos CEL

```{r, message=FALSE, echo=TRUE}
library(affy)

library(annotate)

setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE8879/")

GSE8879_affy <- ReadAffy(filenames=filelist)

GSE8879_affydb<-annPkgName(GSE8879_affy@annotation,type="db")

require(GSE8879_affydb, character.only=TRUE)

GSE8879_eset<-rma(GSE8879_affy,verbose=FALSE)

GSE8879_eset.e<-exprs(GSE8879_eset) ## archivo de matriz obtenido

library(annaffy)

symbols<-as.character(aafSymbol(as.character(rownames(eset_GSE110633et)),GSE8879_affydb))

# genes<-as.character(aafUniGene(as.character(rownames(GSE8879_eset)),GSE8879_affydb)) NO FUNCIONA
```

## En términos generales, la matriz del chip debe filtrarse. Puede usar el siguiente código para ser más estricto

```{r, message=FALSE, echo=TRUE}
setwd('C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE8879/')
library(affy)
dir_cels='C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE8879/'
data <- ReadAffy(celfile.path=dir_cels)
eset <- affy::rma(data)
calls <- mas5calls(data) # get PMA calls
calls <- exprs(calls)
absent <- rowSums(calls == 'A') # how may samples are each gene 'absent' in all
samples
absent <- which (absent == ncol(calls)) # which genes are 'absent' in all samples
GSE8879_Filtered <- eset[-absent,] # filters out the genes 'absent' in all samples
```

Grupos experimentales: diagnostic leukemic blasts of early T-cell precursor acute lymphoblastic leukemia (ETP), diagnostic leukemic blasts of T-cell precursor acute lymphoblastic leukemia.



```{r, message=FALSE, echo=TRUE}
GSE8879_getGEO[["GSE8879_series_matrix.txt.gz"]]@phenoData@data[["title"]]
table(GSE8879_getGEO[["GSE8879_series_matrix.txt.gz"]]@phenoData@data[["characteristics_ch1"]])
```

# GSE10609


```{r, message=FALSE, echo=TRUE, warning=FALSE}
require(Biobase)
datadir <- "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/"
```


```{r, message=FALSE, echo=TRUE}
library(GEOquery)
GSE10609_getGEO <- getGEO("GSE10609", GSEMatrix =TRUE, AnnotGPL=TRUE,destdir = "datasets/GSE10609/" )
```


```{r, message=FALSE, echo=TRUE, error=TRUE}
getGEOSuppFiles ("GSE10609") ## Descargar datos sin procesar
setwd("datasets/GSE10609/") ## Ingresa al directorio de descarga
dir() ## Ver el contenido del archivo
untar("GSE10609_RAW.tar") ## Descomprime el archivo
archivos<- dir(pattern = "gz$") ## Cargar archivos
sapply(archivos, gunzip) ## Fusionar archivos
filelist<-list.files(pattern = ".CEL$")
```


## Unificar el procesamiento de archivos CEL

```{r, message=FALSE, echo=TRUE}
library(affy)

library(annotate)

setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE10609/")

GSE10609_affy <- ReadAffy(filenames=filelist)

GSE10609_affydb<-annPkgName(GSE10609_affy@annotation,type="db")

require(GSE10609_affydb, character.only=TRUE)

GSE10609_eset<-rma(GSE10609_affy,verbose=FALSE)

GSE10609_eset.e<-exprs(GSE10609_eset) ## archivo de matriz obtenido

library(annaffy)

symbols<-as.character(aafSymbol(as.character(rownames(GSE10609_eset)),GSE10609_affydb))

# genes<-as.character(aafUniGene(as.character(rownames(GSE10609_eset)),GSE10609_affydb)) NO FUNCIONA
```

## En términos generales, la matriz del chip debe filtrarse. Puede usar el siguiente código para ser más estricto

```{r, message=FALSE, echo=TRUE}
setwd('C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE10609/')
library(affy)
dir_cels='C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE10609/'
data <- ReadAffy(celfile.path=dir_cels)
eset <- affy::rma(data)
calls <- mas5calls(data) # get PMA calls
calls <- exprs(calls)
absent <- rowSums(calls == 'A') # how may samples are each gene 'absent' in all
samples
absent <- which (absent == ncol(calls)) # which genes are 'absent' in all samples
GSE10609_Filtered <- eset[-absent,] # filters out the genes 'absent' in all samples
```



# GSE14618


```{r, message=FALSE, echo=TRUE, warning=FALSE}
datadir <- "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/"
# datadir <- "C:/Users/crist/Documents/TFM/datosyeso/"
```


```{r, message=FALSE, echo=TRUE}
library(GEOquery)
GSE14618_getGEO <- getGEO("GSE14618", GSEMatrix =TRUE, AnnotGPL=TRUE,destdir = "datasets/GSE14618/" )
```

HAY QUE EXTRAER A MANO LAS COSAS. 

```{r, message=FALSE, echo=TRUE, error=TRUE}
getGEOSuppFiles ("GSE14618") ## Descargar datos sin procesar
setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/GSE14618/") ## Ingresa al directorio de descarga
dir() ## Ver el contenido del archivo
untar("GSE14618_RAW.tar") ## Descomprime el archivo
# HAY QUE EXTRAER LO DEMAS A MANO
archivos<- dir(pattern = "gz$") ## Cargar archivos
sapply(archivos, gunzip) ## Fusionar archivos
filelist<-list.files(pattern = ".CEL$")

```

A PARTIR DE AQUÍ AL SIGUIENTE HACERLO A MANO, NO SALE BIEN, hay archivos .CEL con carácteres raros.

```{r, message=FALSE, echo=TRUE, error=TRUE}

setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE14618/")

```

https://sbc.shef.ac.uk/geo_tutorial/tutorial.nb.html#Importing_the_data

Compruebe cuántas plataformas se utilizan. Si hay más de un conjunto de datos presente, puede analizar el otro conjunto de datos cambiando el número dentro de [[...]].

```{r, message=FALSE, echo=TRUE, error=TRUE}
length(GSE14618_getGEO)

```

```{r, message=FALSE, echo=TRUE, error=TRUE}
GSE14618_GPL570<-GSE14618_getGEO[[1]]
GSE14618_GPL96<-GSE14618_getGEO[[2]]
```


```{r, message=FALSE, echo=TRUE, error=TRUE}
(pData(GSE14618_GPL570))[1:10,1:10] ## print the sample information
(fData(GSE14618_GPL570))[1:10,1:10] ## print the gene annotation
(exprs(GSE14618_GPL570))[1:10] ## print the expression data
```

## Comprobar la normalización y las escalas utilizadas

```{r, message=FALSE, echo=TRUE, error=TRUE}
summary(exprs(GSE14618_GPL570))
summary(exprs(GSE14618_GPL96))
```

Los valores son pequeños (<16). Por lo tanto no requeriremos transformaciones adicionales.

```{r, message=FALSE, echo=TRUE, error=TRUE}
boxplot(exprs(GSE14618_GPL570),outline=FALSE)
boxplot(exprs(GSE14618_GPL96),outline=FALSE)

```

## Inspeccionar las variables clínicas

```{r, message=FALSE, echo=TRUE, error=TRUE}
library(dplyr)
(sampleInfo_GPL570 <- pData(GSE14618_GPL570))[1:10,]
(sampleInfo_GPL96 <- pData(GSE14618_GPL96))[1:10,]
```

Entonces, tenemos tres grupos:

```{r, message=FALSE, echo=TRUE, error=TRUE}
table(sampleInfo_GPL570$source_name_ch1)
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
GSE14618_GPL570@phenoData@data[["data_processing"]]
```

Por ello vamos a pensar que no necesitan normalización, ay que ya está hecha.

# GSE26713


```{r, message=FALSE, echo=TRUE, warning=FALSE}

datadir <- "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/"
```


```{r, message=FALSE, echo=TRUE}
library(GEOquery)
GSE26713_getGEO <- getGEO("GSE26713", GSEMatrix =TRUE, AnnotGPL=TRUE,destdir = "datasets/GSE26713/" )

GSE26713_getGEO<-GSE26713_getGEO[[1]]
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
getGEOSuppFiles ("GSE26713") ## Descargar datos sin procesar
setwd("datasets/GSE26713/") ## Ingresa al directorio de descarga
dir() ## Ver el contenido del archivo
untar("GSE26713_RAW.tar") ## Descomprime el archivo
archivos<- dir(pattern = "gz$") ## Cargar archivos
sapply(archivos, gunzip) ## Fusionar archivos
filelist<-list.files(path = "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE26713", pattern = ".CEL$")
```


## Unificar el procesamiento de archivos CEL

```{r, message=FALSE, echo=TRUE}

library(affy)

library(annotate)

setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE26713/")

GSE26713_affy <- ReadAffy(filenames=filelist)

GSE26713_affydb<-annPkgName(GSE26713_affy@annotation,type="db")

require(GSE26713_affydb, character.only=TRUE)

GSE26713_eset<-affy::rma(GSE26713_affy,verbose=FALSE)

GSE26713_eset.e<-exprs(GSE26713_eset) ## archivo de matriz obtenido

library(annaffy)

symbols<-as.character(aafSymbol(as.character(rownames(GSE26713_eset)),GSE26713_affydb))

# genes<-as.character(aafUniGene(as.character(rownames(GSE26713_eset)),GSE26713_affydb)) NO FUNCIONA
```

## En términos generales, la matriz del chip debe filtrarse. Puede usar el siguiente código para ser más estricto

```{r, message=FALSE, echo=TRUE}
setwd('C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE26713/')

dir_cels='C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE26713/'
data <- ReadAffy(celfile.path=dir_cels)
require(affy)
eset <- affy::rma(data)

calls <- mas5calls(data) # get PMA calls
calls <- exprs(calls)
absent <- rowSums(calls == 'A') # how may samples are each gene 'absent' in all
samples
absent <- which (absent == ncol(calls)) # which genes are 'absent' in all samples
GSE26713_Filtered <- eset[-absent,] # filters out the genes 'absent' in all samples
```





# GSE28703


```{r, message=FALSE, echo=TRUE, warning=FALSE}

datadir <- "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/"
```


```{r, message=FALSE, echo=TRUE}

GSE28703_getGEO <- getGEO("GSE28703", GSEMatrix =TRUE, AnnotGPL=TRUE,destdir = "datasets/GSE28703/" )
```

PRIMERO DESCOMPRIMIR ANTES DE list.files.

```{r, message=FALSE, echo=TRUE, error=TRUE}
getGEOSuppFiles ("GSE28703") ## Descargar datos sin procesar
setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE28703/") ## Ingresa al directorio de descarga
dir() ## Ver el contenido del archivo
untar("GSE28703_RAW.tar") ## Descomprime el archivo
archivos<- dir(pattern = "gz$") ## Cargar archivos
sapply(archivos, gunzip) ## Fusionar archivos
filelist<-list.files(pattern = ".CEL$")
```


## Unificar el procesamiento de archivos CEL

```{r, message=FALSE, echo=TRUE}

setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE28703/")

GSE28703_affy <- ReadAffy(filenames=filelist)

GSE28703_affydb<-annPkgName(GSE28703_affy@annotation,type="db")

require(GSE28703_affydb, character.only=TRUE)

GSE28703_eset<-affy::rma(GSE28703_affy,verbose=FALSE)

GSE28703_eset.e<-exprs(GSE28703_eset) ## archivo de matriz obtenido

symbols<-as.character(aafSymbol(as.character(rownames(GSE28703_eset)),GSE28703_affydb))

# genes<-as.character(aafUniGene(as.character(rownames(GSE28703_eset)),GSE28703_affydb)) NO FUNCIONA
```

No funciona el filtrado. Haremos uno general posteriormente.



# GSE32215


```{r, message=FALSE, echo=TRUE, warning=FALSE}

datadir <- "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/"
```


```{r, message=FALSE, echo=TRUE}
library(GEOquery)
GSE32215_getGEO <- getGEO("GSE32215", GSEMatrix =TRUE, AnnotGPL=TRUE,destdir = "datasets/GSE32215/" )
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
getGEOSuppFiles ("GSE32215") ## Descargar datos sin procesar
setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE32215/") ## Ingresa al directorio de descarga
dir() ## Ver el contenido del archivo
untar("GSE32215_RAW.tar") ## Descomprime el archivo
archivos<- dir(pattern = "gz$") ## Cargar archivos
sapply(archivos, gunzip) ## Fusionar archivos
filelist<-list.files(pattern = ".CEL$")
```


## Unificar el procesamiento de archivos CEL

```{r, message=FALSE, echo=TRUE}
setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE32215/")

GSE32215_affy <- ReadAffy(filenames=filelist)

GSE32215_affydb<-annPkgName(GSE32215_affy@annotation,type="db")

require(GSE32215_affydb, character.only=TRUE)

GSE32215_eset<-affy::rma(GSE32215_affy,verbose=FALSE)

GSE32215_eset.e<-exprs(GSE32215_eset) ## archivo de matriz obtenido

symbols<-as.character(aafSymbol(as.character(rownames(GSE32215_eset)),GSE32215_affydb))

# genes<-as.character(aafUniGene(as.character(rownames(GSE32215_eset)),GSE32215_affydb)) NO FUNCIONA
```

## En términos generales, la matriz del chip debe filtrarse. Puede usar el siguiente código para ser más estricto

No sale el mas5calls(data). Filtrar a mano.

```{r, message=FALSE, echo=TRUE}
setwd('C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE32215/')

dir_cels='C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE32215/'
memory.limit(size=50000)
data <- ReadAffy(celfile.path=dir_cels)
 # si no, lo siguiente da Error: cannot allocate vector of size 2.1 Gb
eset <- affy::rma(data)
calls <- mas5calls(data) # get PMA calls
calls <- exprs(calls)
absent <- rowSums(calls == 'A') # how may samples are each gene 'absent' in all
samples
absent <- which (absent == ncol(calls)) # which genes are 'absent' in all samples
GSE32215_Filtered <- eset[-absent,] # filters out the genes 'absent' in all samples
```



# GSE33469


```{r, message=FALSE, echo=TRUE, warning=FALSE}

datadir <- "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/"
```


```{r, message=FALSE, echo=TRUE}
library(GEOquery)
GSE33469_getGEO <- getGEO("GSE33469", GSEMatrix =TRUE, AnnotGPL=TRUE,destdir = "datasets/GSE33469/" )
```


```{r, message=FALSE, echo=TRUE, error=TRUE}
getGEOSuppFiles ("GSE33469") ## Descargar datos sin procesar
setwd("datasets/GSE33469/") ## Ingresa al directorio de descarga
dir() ## Ver el contenido del archivo
untar("GSE33469_RAW.tar") ## Descomprime el archivo
archivos<- dir(pattern = "gz$") ## Cargar archivos
sapply(archivos, gunzip) ## Fusionar archivos
filelist<-list.files(pattern = "datasets/GSE33469/.CEL$")
```


## Unificar el procesamiento de archivos CEL

No sale, no hay archivos .CEL, solo txt.

```{r, message=FALSE, echo=TRUE, error=TRUE}

setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE33469/")


```

https://sbc.shef.ac.uk/geo_tutorial/tutorial.nb.html#Importing_the_data

Compruebe cuántas plataformas se utilizan. Si hay más de un conjunto de datos presente, puede analizar el otro conjunto de datos cambiando el número dentro de [[...]].

```{r, message=FALSE, echo=TRUE, error=TRUE}
length(GSE33469_getGEO)

```

Solo tenemos una plataforma. La ponemos como única.

```{r, message=FALSE, echo=TRUE, error=TRUE}
GSE33469_getGEO<- GSE33469_getGEO[[1]]

```


```{r, message=FALSE, echo=TRUE, error=TRUE}
(pData(GSE33469_getGEO))[1:10,1:10] ## print the sample information
(fData(GSE33469_getGEO))[1:10,1:10] ## print the gene annotation
(exprs(GSE33469_getGEO))[1:10] ## print the expression data
```

## Comprobar la normalización y las escalas utilizadas

```{r, message=FALSE, echo=TRUE, error=TRUE}
summary(exprs(GSE33469_getGEO))

```

Los valores son pequeños (<16). Por lo tanto no requeriremos transformaciones adicionales.

```{r, message=FALSE, echo=TRUE, error=TRUE}
boxplot(exprs(GSE33469_getGEO),outline=FALSE)
```

## Inspeccionar las variables clínicas

```{r, message=FALSE, echo=TRUE, error=TRUE}
library(dplyr)
(sampleInfo_GSE33469 <- pData(GSE33469_getGEO))[1:10,]
```

Entonces, parece que tenemos solo un grupo. Buscamos la serie en ncbi, y sale https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE33469. En el artículo, en Materiales y Métodos, no dicen que haya dos tipos de pacientes, aunque sí que tienen algunos timocitos positivos y negativos (no dicen qué muestras).

```{r, message=FALSE, echo=TRUE, error=TRUE}
table(sampleInfo_GSE33469$source_name_ch1)
```


# GSE33470


```{r, message=FALSE, echo=TRUE, warning=FALSE}

datadir <- "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/"
```


```{r, message=FALSE, echo=TRUE}

GSE33470_getGEO <- getGEO("GSE33470", GSEMatrix =TRUE, AnnotGPL=TRUE,destdir = "datasets/GSE33470/" )
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
getGEOSuppFiles ("GSE33470") ## Descargar datos sin procesar
setwd("datasets/GSE33470/") ## Ingresa al directorio de descarga
dir() ## Ver el contenido del archivo
untar("GSE33470_RAW.tar") ## Descomprime el archivo
archivos<- dir(pattern = "gz$") ## Cargar archivos
sapply(archivos, gunzip) ## Fusionar archivos
filelist<-list.files(pattern = "datasets/GSE33470/.CEL$")
```


No hay archivos.CEL, por lo que el resto se hará a mano.

```{r, message=FALSE, echo=TRUE, error=TRUE}

setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE33470/")

```

https://sbc.shef.ac.uk/geo_tutorial/tutorial.nb.html#Importing_the_data

Compruebe cuántas plataformas se utilizan. Si hay más de un conjunto de datos presente, puede analizar el otro conjunto de datos cambiando el número dentro de [[...]].

```{r, message=FALSE, echo=TRUE, error=TRUE}
length(GSE33470_getGEO)

```

```{r, message=FALSE, echo=TRUE, error=TRUE}
GSE33470_getGEO<-GSE33470_getGEO[[1]]

```


```{r, message=FALSE, echo=TRUE, error=TRUE}
(pData(GSE33470_getGEO))[1:10,1:10] ## print the sample information
(fData(GSE33470_getGEO))[1:10,1:10] ## print the gene annotation
(exprs(GSE33470_getGEO))[1:10] ## print the expression data
```

## Comprobar la normalización y las escalas utilizadas

```{r, message=FALSE, echo=TRUE, error=TRUE}
summary(exprs(GSE33470_getGEO))

```

Los valores son pequeños (<16). Por lo tanto no requeriremos transformaciones adicionales.

```{r, message=FALSE, echo=TRUE, error=TRUE}
boxplot(exprs(GSE33470_getGEO),outline=FALSE)

```

## Inspeccionar las variables clínicas

```{r, message=FALSE, echo=TRUE, error=TRUE}
(sampleInfo_GSE33470 <- pData(GSE33470_getGEO))[1:10,]
```

Entonces, tenemos siete grupos:

```{r, message=FALSE, echo=TRUE, error=TRUE}
table(sampleInfo_GSE33470$source_name_ch1)
sampleInfo_GSE33470$title
```

En characteristics_ch1 no se indica que las muestras sena de los mismos pacientes.


# GSE37389


```{r, message=FALSE, echo=TRUE, warning=FALSE}

datadir <- "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/"
```


```{r, message=FALSE, echo=TRUE}
library(GEOquery)
GSE37389_getGEO <- getGEO("GSE37389", GSEMatrix =TRUE, AnnotGPL=TRUE,destdir = "datasets/GSE37389/" )
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
getGEOSuppFiles ("GSE37389") ## Descargar datos sin procesar
setwd("datasets/GSE37389/") ## Ingresa al directorio de descarga
dir() ## Ver el contenido del archivo
untar("GSE37389_RAW.tar") ## Descomprime el archivo
archivos<- dir(pattern = "gz$") ## Cargar archivos
sapply(archivos, gunzip) ## Fusionar archivos
filelist<-list.files(pattern = "datasets/GSE37389/.CEL$")
```


## Unificar el procesamiento de archivos CEL

No hay CEL, por lo que el resto se hará a mano.

```{r, message=FALSE, echo=TRUE, error=TRUE}

setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE37389/")

```

https://sbc.shef.ac.uk/geo_tutorial/tutorial.nb.html#Importing_the_data

Compruebe cuántas plataformas se utilizan. Si hay más de un conjunto de datos presente, puede analizar el otro conjunto de datos cambiando el número dentro de [[...]].

```{r, message=FALSE, echo=TRUE, error=TRUE}
length(GSE37389_getGEO)

```

```{r, message=FALSE, echo=TRUE, error=TRUE}
GSE37389_getGEO<-GSE37389_getGEO[[1]]

```


```{r, message=FALSE, echo=TRUE, error=TRUE}
(pData(GSE37389_getGEO))[1:10,1:10] ## print the sample information
(fData(GSE37389_getGEO))[1:10,1:10] ## print the gene annotation
(exprs(GSE37389_getGEO))[1:10] ## print the expression data
```

## Comprobar la normalización y las escalas utilizadas

```{r, message=FALSE, echo=TRUE, error=TRUE}
summary(exprs(GSE37389_getGEO))

```

Los valores son pequeños (<16). Por lo tanto no requeriremos transformaciones adicionales.

```{r, message=FALSE, echo=TRUE, error=TRUE}
boxplot(exprs(GSE37389_getGEO),outline=FALSE)

```

Los datos no parecen normalizados, ya que las muestras son muy diferentes. 

## Inspeccionar las variables clínicas

```{r, message=FALSE, echo=TRUE, error=TRUE}
(sampleInfo_GSE37389 <- pData(GSE37389_getGEO))[1:10,]
```

Parece que hay dos grupos (empiezan por G y A), pero en el resto de variables no se indica que difieran en nada. 

```{r, message=FALSE, echo=TRUE, error=TRUE}
table(sampleInfo_GSE37389$source_name_ch1)
sampleInfo_GSE37389$title
```

En characteristics_ch1 no se indica que las muestras sena de los mismos pacientes. En ncbi indican que el articulo es Mirji G, Bhat J, Kode J, Banavali S et al. Risk stratification of T-cell Acute Lymphoblastic Leukemia patients based on gene expression, mutations and copy number variation. Leuk Res 2016 Jun;45:33-9. En Materiales y Métodos, en el 2.2, cuentan:

"Se utilizaron blastos leucémicos de 14 de los 68 pacientes con LLA-T (mencionados en la Sección 2.1) para el perfil de expresión génica. El ARN total se aisló de blastos leucémicos de pacientes con TCR alfa-beta  +  T-ALL (n  =  9) y TCR gamma-delta  +  T-ALL (n  =  5) usando el reactivo TRIzol (Invitrogen, Carlsbad, CA, EE. UU.) según el protocolo estándar".

Por ello, diferenciaremos las nueve muestras de A (TCR alfa-beta  +  T-ALL) y las 5 de G (TCRgamma-delta  +  T-ALL).


# GSE56488


```{r, message=FALSE, echo=TRUE, warning=FALSE, error=TRUE}

datadir <- "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/"
```


```{r, message=FALSE, echo=TRUE, error=TRUE}
library(GEOquery)
GSE56488_getGEO <- getGEO("GSE56488", GSEMatrix =TRUE, AnnotGPL=TRUE,destdir = "datasets/GSE56488/" )
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
getGEOSuppFiles ("GSE56488") ## Descargar datos sin procesar
setwd("datasets/GSE56488/") ## Ingresa al directorio de descarga
dir() ## Ver el contenido del archivo
untar("GSE56488_RAW.tar") ## Descomprime el archivo
archivos<- dir(pattern = "gz$") ## Cargar archivos
sapply(archivos, gunzip) ## Fusionar archivos
filelist<-list.files(path = "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE56488/", pattern = '.CEL$')
```


## Unificar el procesamiento de archivos CEL

```{r, message=FALSE, echo=TRUE, error=TRUE}

setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE56488/")

GSE56488_affy <- ReadAffy(filenames=filelist)


```

## Unificar el procesamiento de archivos CEL

Usaremos otro paquete.

```{r, message=FALSE, echo=TRUE}
setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE56488/")

library(oligo)
celFiles <- list.celfiles(full.names = TRUE)
GSE56488_affyExpressionFS <- read.celfiles(celFiles)
```

```{r, message=FALSE, echo=TRUE}

setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE56488/")


GSE56488_affy <- GSE56488_affyExpressionFS# en vez de:

# GSE62156_affy <- ReadAffy(filenames=filelist)

GSE56488_affy@annotation

require(annotate)
GSE56488_affydb<-annPkgName(GSE56488_affy@annotation,type="db")

require(GSE56488_affydb, character.only=TRUE)

GSE56488_eset <-oligo::rma(GSE56488_affyExpressionFS) #en vez de:

# GSE56488_eset<-rma(GSE56488_affy,verbose=FALSE)

GSE56488_eset.e<-exprs(GSE56488_eset)


# symbols<-as.character(aafSymbol(as.character(rownames(GSE56488_eset)),GSE56488_affydb)) NO SALE

# genes<-as.character(aafUniGene(as.character(rownames(GSE62156_eset)),GSE62156_affydb)) NO FUNCIONA
```


De cualquier forma, tampoco hemos filtrado esto, como antes. Lo haremos posteriromente.





# GSE62156


```{r, message=FALSE, echo=TRUE, warning=FALSE, error=TRUE}

datadir <- "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/"
```


```{r, message=FALSE, echo=TRUE, error=TRUE}

GSE62156_getGEO <- getGEO("GSE62156", GSEMatrix =TRUE, AnnotGPL=TRUE,destdir = "datasets/GSE62156/" )
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
getGEOSuppFiles ("GSE62156") ## Descargar datos sin procesar
setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE62156/") ## Ingresa al directorio de descarga
dir() ## Ver el contenido del archivo
untar("GSE62156_RAW.tar") ## Descomprime el archivo
archivos<- dir(pattern = "gz$") ## Cargar archivos
sapply(archivos, gunzip) ## Fusionar archivos
filelist<-list.files(pattern = ".CEL$")

```


## Unificar el procesamiento de archivos CEL

```{r, message=FALSE, echo=TRUE}

setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE62156/")

GSE62156_affy <- ReadAffy(filenames=filelist)

GSE62156_affydb<-annPkgName(GSE62156_affy@annotation,type="db")

require(GSE62156_affydb, character.only=TRUE)

GSE62156_eset<-affy::rma(GSE62156_affy,verbose=FALSE)

GSE62156_eset.e<-exprs(GSE62156_eset) ## archivo de matriz obtenido

symbols<-as.character(aafSymbol(as.character(rownames(GSE62156_eset)),GSE62156_affydb))

# genes<-as.character(aafUniGene(as.character(rownames(GSE62156_eset)),GSE62156_affydb)) NO FUNCIONA
```

## En términos generales, la matriz del chip debe filtrarse. Puede usar el siguiente código para ser más estricto

```{r, message=FALSE, echo=TRUE}
setwd('C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE62156/')
dir_cels='C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE62156/'
data <- ReadAffy(celfile.path=dir_cels)
eset <- affy::rma(data)
calls <- mas5calls(data) # get PMA calls
calls <- exprs(calls)
absent <- rowSums(calls == 'A') # how may samples are each gene 'absent' in all
samples
absent <- which (absent == ncol(calls)) # which genes are 'absent' in all samples
GSE62156_Filtered <- eset[-absent,] # filters out the genes 'absent' in all samples
```




# GSE110633


```{r, message=FALSE, echo=TRUE, warning=FALSE, error=TRUE}

# datadir <- "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/"

datadir<-'C:/Users/crist/Documents/TFM/'
```


```{r, message=FALSE, echo=TRUE, error=TRUE}
library(GEOquery)
GSE110633_getGEO <- getGEO("GSE110633", GSEMatrix =TRUE, AnnotGPL=TRUE,destdir = "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE110633/" )

# GSE110633_getGEO <- getGEO("GSE110633", GSEMatrix =TRUE, AnnotGPL=TRUE,destdir = "C:/Users/crist/Documents/TFM/datosyeso/" )
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
# setwd("C:/Users/crist/Documents/TFM/datosyeso/") 
getGEOSuppFiles ("GSE110633") ## Descargar datos sin procesar
setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE110633/") ## Ingresa al directorio de descarga
list.files(pattern = ".CEL$")
list.files()
```

```{r, message=FALSE, echo=TRUE}
GSE110633_getGEO<-GSE110633_getGEO[[1]]
```

```{r, message=FALSE, echo=TRUE}
GSE110633_getGEO@phenoData@data[["subgroup:ch1"]]
table(GSE110633_getGEO@phenoData@data[["subgroup:ch1"]])
GSE110633_getGEO@phenoData@data[["characteristics_ch1"]]
```


Buscando en internet nuestros cuatro grupos TAL TLX HOXA IMM, nos aparece esto: https://biblio.ugent.be/publication/8518880/file/8518881.pdf. TAL: TAL T-ALL, IMM: Immature T-ALL, HOXA: HOXA-overexpressing T-ALL. TLX: T-cell Leukemia Homeobox.

No hay CEL. los archivos son de tipo ReadsPerGene.out.tab. Este tipo de formato es de STAR.
https://ycl6.gitbook.io/guide-to-rna-seq-analysis/differential-expression-analysis/differential-gene-expression/dge-analysis-with-star-input



```{r, message=FALSE, echo=TRUE}
dir = "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE110633/"

# dir = "C:/Users/crist/Documents/TFM/datosyeso/"

(files = list.files(dir, "*ReadsPerGene.out.tab$", full.names = T))

```



```{r, message=FALSE, echo=TRUE}
library(data.table)

countData = data.frame(fread(files[1]))[c(1,4)]

# Loop and read the 4th column remaining files
for(i in 2:length(files)) {
        countData = cbind(countData, data.frame(fread(files[i]))[4])
}

# Skip first 4 lines, count data starts on the 5th line
GSE110633_countData = countData[c(5:nrow(countData)),]

colnames(GSE110633_countData) = c("GeneID", gsub(paste0(dir,"star/"), "", files))

colnames(GSE110633_countData) = gsub("_ReadsPerGene.out.tab", "", colnames(GSE110633_countData))

rownames(GSE110633_countData) = GSE110633_countData$GeneID

GSE110633_countData = GSE110633_countData[,c(2:ncol(GSE110633_countData))]

x <- 545:604
y<-paste0('GSM3004', x)
  
colnames(GSE110633_countData)=y
  
```


```{r, message=FALSE, echo=TRUE}
head(GSE110633_countData)
```


```{r, message=FALSE, echo=TRUE}
library(data.table)
library(DESeq2)
library(ggplot2)
library(ggrepel)
```

Análisis de RNA-seq: file:///C:/Users/Copito/OneDrive/Documentos/Master%20bioinf%20y%20bioest/Analisis%20de%20datos%20omicos/PEC2/Solucion.html

```{r, message=FALSE, echo=TRUE}
GSE110633_selectedCounts <- as.matrix(GSE110633_countData)
GSE110633_sampleNames <- (GSE110633_getGEO@phenoData@data[["title"]])

GSE110633_grupos <- (GSE110633_getGEO@phenoData@data[["subgroup:ch1"]])

```

```{r, message=FALSE, echo=TRUE}
GSE110633_colores=c()
for (valor in GSE110633_getGEO@phenoData@data[["subgroup:ch1"]]){
  if (valor=="TAL"){GSE110633_colores=append(GSE110633_colores, 'red')}
  else if (valor=="IMM"){GSE110633_colores=append(GSE110633_colores, 'blue')}
  else if (valor=="HOXA"){GSE110633_colores=append(GSE110633_colores, 'lightgreen')}
  else if (valor=="HOXA"){GSE110633_colores=append(GSE110633_colores, 'orangered1')}
  else {GSE110633_colores=append(GSE110633_colores, 'yellow')}
}
```



```{r, message=FALSE, echo=TRUE}
head(GSE110633_selectedTargets <- data.frame(samples = GSE110633_sampleNames, group = GSE110633_grupos, cols = GSE110633_colores))

rownames(GSE110633_selectedTargets) <- GSE110633_selectedTargets[, 1]
```

Faltan las demás partes del análisis: preprocesado de los datos, exploraciones, etc. Seguir con file:///C:/Users/Copito/OneDrive/Documentos/Master%20bioinf%20y%20bioest/Analisis%20de%20datos%20omicos/PEC2/Solucion.html.


# GSE110636


```{r, message=FALSE, echo=TRUE, warning=FALSE, error=TRUE}

datadir <- "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/"
```


```{r, message=FALSE, echo=TRUE, error=TRUE}
library(GEOquery)
GSE110636_getGEO <- getGEO("GSE110636", GSEMatrix =TRUE, AnnotGPL=TRUE,destdir = "datasets/GSE110636/" )
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
getGEOSuppFiles("GSE110636") ## Descargar datos sin procesar
setwd("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE110636/") ## Ingresa al directorio de descarga
list.files(pattern = ".CEL$")
list.files()
```

```{r, message=FALSE, echo=TRUE}
GSE110636_getGEO<-GSE110636_getGEO[[1]]
```

```{r, message=FALSE, echo=TRUE}
GSE110636_getGEO@phenoData@data[["subgroup:ch1"]]
table(GSE110636_getGEO@phenoData@data[["subgroup:ch1"]])
GSE110636_getGEO@phenoData@data[["characteristics_ch1"]]
```


Buscando en internet nuestros cuatro grupos TAL TLX HOXA IMM, nos aparece esto: https://biblio.ugent.be/publication/8518880/file/8518881.pdf. TAL: TAL T-ALL, IMM: Immature T-ALL, HOXA: HOXA-overexpressing T-ALL. TLX: T-cell Leukemia Homeobox.

No hay CEL. los archivos son de tipo ReadsPerGene.out.tab. Este tipo de formato es de STAR.
https://ycl6.gitbook.io/guide-to-rna-seq-analysis/differential-expression-analysis/differential-gene-expression/dge-analysis-with-star-input


```{r, message=FALSE, echo=TRUE}
dir = "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE110636/"

(files = list.files(dir, "*ReadsPerGene.out.tab$", full.names = T))

```



```{r, message=FALSE, echo=TRUE}
library(data.table)
countData = data.frame(fread(files[1]))[c(1,4)]

# Loop and read the 4th column remaining files
for(i in 2:length(files)) {
        countData = cbind(countData, data.frame(fread(files[i]))[4])
}

# Skip first 4 lines, count data starts on the 5th line
countData = countData[c(5:nrow(countData)),]
colnames(countData) = c("GeneID", gsub(paste0(dir,"star/"), "", files))
colnames(countData) = gsub("_ReadsPerGene.out.tab", "", colnames(countData))
rownames(countData) = countData$GeneID

GSE110636_countData = countData[,c(2:ncol(countData))]

x <- 620:644
y<-paste0('GSM3004', x)
  
colnames(GSE110636_countData)=y
  
```


```{r, message=FALSE, echo=TRUE}
head(GSE110636_countData)
```

Análisis de RNA-seq: file:///C:/Users/Copito/OneDrive/Documentos/Master%20bioinf%20y%20bioest/Analisis%20de%20datos%20omicos/PEC2/Solucion.html

```{r, message=FALSE, echo=TRUE}
GSE110636_selectedCounts <- as.matrix(GSE110636_countData)

GSE110636_sampleNames <- (GSE110636_getGEO@phenoData@data[["title"]])

GSE110636_grupos <- (GSE110636_getGEO@phenoData@data[["subgroup:ch1"]])

```

```{r, message=FALSE, echo=TRUE}
GSE110636_colores=c()
for (valor in GSE110636_getGEO@phenoData@data[["subgroup:ch1"]]){
  if (valor=="TAL"){GSE110636_colores=append(GSE110636_colores, 'red')}
  else if (valor=="IMM"){GSE110636_colores=append(GSE110636_colores, 'blue')}
  else if (valor=="HOXA"){GSE110636_colores=append(GSE110636_colores, 'purple1')}
  else if (valor=="TLX"){GSE110636_colores=append(GSE110636_colores, 'peru')}
  else {GSE110636_colores=append(GSE110636_colores, 'yellow')}
}
```



```{r, message=FALSE, echo=TRUE}
head(GSE110636_selectedTargets <- data.frame(samples = GSE110636_sampleNames, group = GSE110636_grupos, cols = GSE110636_colores))
rownames(GSE110636_selectedTargets) <- GSE110636_selectedTargets[, 1]
```

Faltan las demás partes del análisis: preprocesado de los datos, exploraciones, etc. Seguir con file:///C:/Users/Copito/OneDrive/Documentos/Master%20bioinf%20y%20bioest/Analisis%20de%20datos%20omicos/PEC2/Solucion.html.



# Preprocesado 1. Datos de microarrays

# GSE8879

## Creación de un subconjunto para el análisis

```{r, message=FALSE, echo=TRUE}
dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE8879/"
archivosCel <-list.files(path = dir, pattern = ".CEL$")
```

```{r, message=FALSE, echo=TRUE}

(shortNames <- GSE8879_getGEO[["GSE8879_series_matrix.txt.gz"]]@phenoData@data[["title"]])

GSE8879_getGEO[["GSE8879_series_matrix.txt.gz"]]@phenoData@data[["characteristics_ch1"]]

cols <- c(rep("red", 1), rep("blue", 4), rep("red", 1), rep("blue", 7),
          rep("red", 1), rep("blue", 3), rep("red", 1), rep("blue", 4),
          rep("red", 1), rep("blue", 27), rep("red", 1), rep("blue", 1),
          rep("red", 3))
# rojo: early T-cell precursor/ETP, azul: T-cell precursor acute/no ETP 

grup <- c(rep("ETP", 1), rep("No ETP diag", 4),
          rep("ETP", 1), rep("No ETP diag", 7),
          rep("ETP", 1), rep("No ETP diag", 3),
          rep("ETP", 1), rep("No ETP diag", 4),
          rep("ETP", 1), rep("No ETP diag", 27),
          rep("ETP", 1), rep("No ETP diag", 1), rep("ETP", 3))

GSE8879_targets <- data.frame(fileNames = archivosCel, shortName = shortNames, grupo = grup, colores = cols)
```



```{r, message=FALSE, echo=TRUE}


GSE8879_selectedTargets <- GSE8879_targets

rownames(GSE8879_selectedTargets) <- GSE8879_selectedTargets$shortName

table(GSE8879_selectedTargets$grupo)

```

## Preprocesado: exploración

```{r, message=FALSE, echo=TRUE}
require(Biobase)

sampleInfo <- AnnotatedDataFrame(GSE8879_selectedTargets)

library(oligo)

CELfiles <- archivosCel

dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE8879/"

GSE8879_rawData <- read.celfiles(file.path(dir, CELfiles), phenoData = sampleInfo)

colnames(exprs(GSE8879_rawData)) <- rownames(pData(GSE8879_rawData))
```

```{r, message=FALSE, echo=TRUE}
colores <- pData(GSE8879_rawData)$colores
grupos <- as.factor(pData(GSE8879_rawData)$grupo)
numSamples <- nrow(pData(GSE8879_rawData))
sampleNames <- pData(GSE8879_rawData)$shortName
```

```{r, message=FALSE, echo=TRUE}
hist(GSE8879_rawData, main = "Distribución de valores", col = colores, lty = 1:numSamples)
legend(x = "topright", legend = sampleNames, col = colores, lty = 1:numSamples, cex = 0.6)
```

```{r, message=FALSE, echo=TRUE}
boxplot(GSE8879_rawData, cex.axis = 0.6, col = colores, las = 2, names = sampleNames, main = "Distribución de la señal")
```

El histograma y el diagrama de caja muestran que las distribuciones de los datos son similares en formas pero no en posición, lo que ya indica que será preciso algún tipo de centrado.

```{r, message=FALSE, echo=TRUE}
library(ggplot2)
library(ggrepel)
plotPCA3 <- function(datos, labels, factor, title, scale, colores, size = 1.5, glineas = 0.25) {
    data <- prcomp(t(datos), scale = scale)
    # plot adjustments
    dataDf <- data.frame(data$x)
    Group <- factor
    loads <- round(data$sdev^2/sum(data$sdev^2) * 100, 1)
    # main plot
    p1 <- ggplot(dataDf, aes(x = PC1, y = PC2)) + theme_classic() + geom_hline(yintercept = 0,
        color = "gray70") + geom_vline(xintercept = 0, color = "gray70") + geom_point(aes(color = Group),
        alpha = 0.55, size = 3) + coord_cartesian(xlim = c(min(data$x[, 1]) - 5,
        max(data$x[, 1]) + 5)) + scale_fill_discrete(name = "Group")
    # avoiding labels superposition
    p1 + geom_text_repel(aes(y = PC2 + 0.25, label = labels), segment.size = 0.25,
        size = size) + labs(x = c(paste("PC1", loads[1], "%")), y = c(paste("PC2",
        loads[2], "%"))) + ggtitle(title) + theme(plot.title = element_text(hjust = 0.5)) +
        scale_color_manual(values = colores)
}

plotPCA3(exprs(GSE8879_rawData), labels = sampleNames, size = 2, factor = grupos, colores = unique(colores),
    title = "PCA de las muestras", scale = TRUE)
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
dev.off()
```

La representación de los datos en las dos primeras componentes principales muestra cierta separación a lo largo de la segunda componente, aunque no queda claro por qué se distribuyen así.

La primera componente, en cambio, es más difícil de interpretar.

Un cluster jerárquico refuerza esta impresión de que no existe un agrupamiento claro de muestras. Además, junto con el PCA, el cluster indica que el número 9 es distinto al resto de datos.


```{r, message=FALSE, echo=TRUE, error=TRUE}
clust.euclid.average <- hclust(dist(t(exprs(GSE8879_rawData))), method = "average")
plot(clust.euclid.average, labels = sampleNames, main = "Hierarchical clustering of samples",
    hang = -1)
```

## Preprocesado: Control de calidad

```{r, message=FALSE, echo=TRUE}
# library(arrayQualityMetrics)
# arrayQualityMetrics(GSE8879_rawData, outdir = "arrayQuality", intgroup = "grupo", force = TRUE)
```

Hemos guardado un PDF de esto en TFM/datasets/GSE8879, llamado arrayQualityMetrics GSE8879.

## Preprocesado: Análisis de batch

runDate proporciona la fecha de hibridación de los archivos .CEL.

```{r, message=FALSE, echo=TRUE}
library(oligo)
(b<-runDate(GSE8879_rawData))
GSE8879_rawData@phenoData@data[["fileNames"]]
colnames(GSE8879_rawData@assayData[["exprs"]])
```

Hay 16 GSM, correspondientes a los 16 tipos de pacientes. El periodo de tiempo es diferencial. Es posible que haya efectos batch...



```{r PCARaw, message=FALSE, fig.cap="Visualization of the two first Principal Components for raw data"}
library(ggplot2)
library(ggrepel)
plotPCA3 <- function(datos, labels, factor, title, scale, colores, size = 1.5, glineas = 0.25) {
    data <- prcomp(t(datos), scale = scale)
    # plot adjustments
    dataDf <- data.frame(data$x)
    Group <- factor
    loads <- round(data$sdev^2/sum(data$sdev^2) * 100, 1)
    # main plot
    p1 <- ggplot(dataDf, aes(x = PC1, y = PC2)) + theme_classic() + geom_hline(yintercept = 0,
        color = "gray70") + geom_vline(xintercept = 0, color = "gray70") + geom_point(aes(color = Group),
        alpha = 0.55, size = 3) + coord_cartesian(xlim = c(min(data$x[, 1]) - 5,
        max(data$x[, 1]) + 5)) + scale_fill_discrete(name = "Group")
    # avoiding labels superposition
    p1 + geom_text_repel(aes(y = PC2 + 0.25, label = labels), segment.size = 0.25,
        size = size) + labs(x = c(paste("PC1", loads[1], "%")), y = c(paste("PC2",
        loads[2], "%"))) + ggtitle(title) + theme(plot.title = element_text(hjust = 0.5)) +
        scale_color_manual(values = colores)
}
plotPCA3(exprs(GSE8879_rawData), labels = b, size = 2, factor = grupos, colores = unique(colores),
    title = "PCA de las muestras", scale = TRUE)
```

Las muestras parecen que se distribuyen aleatoriamente.


# GSE10609

## Creación de un subconjunto para el análisis

```{r, message=FALSE, echo=TRUE}
dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE10609/"
archivosCel <-GSE10609_getGEO[["GSE10609_series_matrix.txt.gz"]]@phenoData@data[["geo_accession"]] # 91
```

```{r, message=FALSE, echo=TRUE}
char<-GSE10609_getGEO[["GSE10609_series_matrix.txt.gz"]]@phenoData@data[["characteristics_ch1"]] 

shortNames <- GSE10609_getGEO[["GSE10609_series_matrix.txt.gz"]]@phenoData@data[["title"]]

(GSE10609_getGEO[["GSE10609_series_matrix.txt.gz"]]@phenoData@data[["characteristics_ch1"]]) 

a<-substring((GSE10609_getGEO[["GSE10609_series_matrix.txt.gz"]]@phenoData@data[["characteristics_ch1"]])[1:6], 29)

b<-substring((GSE10609_getGEO[["GSE10609_series_matrix.txt.gz"]]@phenoData@data[["characteristics_ch1"]])[7:65], 30) 

c<-substring((GSE10609_getGEO[["GSE10609_series_matrix.txt.gz"]]@phenoData@data[["characteristics_ch1"]])[66:92], 31) 

d<- c(a,b,c)

cols=c()

for (valor in d){
  if (valor=="TAL1"){cols=append(cols, 'red')}
  else if (valor=="HOX11"){cols=append(cols, 'blue')}
  else if (valor=="HOX11L2"){cols=append(cols, 'black')}
  else if (valor=="HOXA"){cols=append(cols, 'purple')}
  else if (valor=="LMO2"){cols=append(cols, 'pink')}
  else if (valor=="unknown"){cols=append(cols, 'goldenrod1')}
}
 

grup <- d

GSE10609_targets <- data.frame(fileNames = archivosCel, shortName = shortNames, grupo = grup, colores = cols)
```


```{r, message=FALSE, echo=TRUE}

GSE10609_selectedTargets <- GSE10609_targets

rownames(GSE10609_selectedTargets) <- GSE10609_selectedTargets$shortName

table(GSE10609_selectedTargets$grupo)

```

## Preprocesado: exploración

```{r, message=FALSE, echo=TRUE}
require(Biobase)

sampleInfo <- AnnotatedDataFrame(GSE10609_selectedTargets)

library(oligo)

CELfiles <- GSE10609_selectedTargets$fileNames

setwd("datasets/GSE10609/") ## Ingresa al directorio

dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/GSE10609/"

GSE10609_rawData <- read.celfiles(list.files(pattern = ".CEL$"), phenoData = sampleInfo)

colnames(exprs(GSE10609_rawData)) <- rownames(pData(GSE10609_rawData))
```

```{r, message=FALSE, echo=TRUE}
colores <- pData(GSE10609_rawData)$colores
grupos <- as.factor(pData(GSE10609_rawData)$grupo)
numSamples <- nrow(pData(GSE10609_rawData))
sampleNames <- pData(GSE10609_rawData)$shortName
```

```{r, message=FALSE, echo=TRUE}
hist(GSE10609_rawData, main = "Distribución de valores", col = colores, lty = 1:numSamples)
legend(x = "topright", legend = sampleNames, col = colores, lty = 1:numSamples, cex = 0.6)
```

```{r, message=FALSE, echo=TRUE}
boxplot(GSE10609_rawData, cex.axis = 0.6, col = colores, las = 2, names = sampleNames, main = "Distribución de la señal")
```

El histograma y el diagrama de caja muestran que las distribuciones de los datos son similares en formas pero no en posición, lo que ya indica que será preciso algún tipo de centrado.

```{r, message=FALSE, echo=TRUE}

plotPCA3(exprs(GSE10609_rawData), labels = sampleNames, size = 2, factor = grupos, colores = unique(colores),
    title = "PCA de las muestras", scale = TRUE, options(ggrepel.max.overlaps = Inf))
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
dev.off()
```

La representación de los datos en las dos primeras componentes principales muestra cierta separación a lo largo de la segunda componente, aunque no queda claro por qué se distribuyen así.

La primera componente, en cambio, es más difícil de interpretar.

Un cluster jerárquico refuerza esta impresión de que no existe un agrupamiento claro de muestras. Además, junto con el PCA, el cluster indica que el número 9 es distinto al resto de datos.


```{r, message=FALSE, echo=TRUE, error=TRUE}
clust.euclid.average <- hclust(dist(t(exprs(GSE10609_rawData))), method = "average")
plot(clust.euclid.average, labels = grupos, main = "Hierarchical clustering of samples",
    hang = -1)

```

Las muestras se parecen poco entre si en general.

## Preprocesado: Control de calidad

```{r, message=FALSE, echo=TRUE, warning=FALSE}
# library(arrayQualityMetrics)
# arrayQualityMetrics(GSE10609_rawData, outdir = "arrayQuality", intgroup = "grupo", force = TRUE)
```

Hemos guardado un PDF de esto en TFM/datasets/GSE10609, llamado arrayQualityMetrics GSE10609.

## Preprocesado: Análisis de batch

runDate proporciona la fecha de hibridación de los archivos .CEL.

```{r, message=FALSE, echo=TRUE}
(b<-runDate(GSE10609_rawData))
GSE10609_rawData@phenoData@data[["fileNames"]]
colnames(GSE10609_rawData@assayData[["exprs"]])
```

Hay 92 GSM, correspondientes a los 92 pacientes. El periodo de tiempo es diferencial. Es posible que haya efectos batch...



```{r PCARaw, message=FALSE, fig.cap="Visualization of the two first Principal Components for raw data"}
library(ggplot2)
library(ggrepel)
plotPCA3(exprs(GSE10609_rawData), labels = b, size = 2, factor = substring(b, 9), colores = unique(colores),
    title = "PCA de las muestras", scale = TRUE)
```

# GSE14618_GPL570

## Creación de un subconjunto para el análisis

```{r, message=FALSE, echo=TRUE}
dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE14618/"
archivosCel <-paste0(sampleInfo_GPL570$geo_accession, '.CEL') # 50, bien

```

```{r, message=FALSE, echo=TRUE}
(char<-GSE14618_GPL570@phenoData@data[["description"]])

shortNames <- GSE14618_GPL570@phenoData@data[["title"]]

a<-substring((GSE14618_GPL570@phenoData@data[["description"]])[1:6], 1, 2)

b<-substring((GSE14618_GPL570@phenoData@data[["description"]])[7:20], 1, 1)

c<-substring((GSE14618_GPL570@phenoData@data[["description"]])[21:50], 1, 1)

d<- c(a,b,c)

cols=c()

for (valor in d){
  if (valor=="NR"){cols=append(cols, 'green2')}
  else if (valor=="F"){cols=append(cols, 'goldenrod')}
  else if (valor=="C"){cols=append(cols, 'deeppink')}
}
 

grup <- d

GSE14618_GPL570_targets <- data.frame(fileNames = archivosCel, shortName = shortNames, grupo = grup, colores = cols)
```

```{r, message=FALSE, echo=TRUE}


GSE14618_GPL570_selectedTargets <- GSE14618_GPL570_targets

rownames(GSE14618_GPL570_selectedTargets) <- GSE14618_GPL570_selectedTargets$shortName

table(GSE14618_GPL570_selectedTargets$grupo)

```

## Preprocesado: exploración

```{r, message=FALSE, echo=TRUE}
require(Biobase)

sampleInfo <- AnnotatedDataFrame(GSE14618_GPL570_selectedTargets)

library(oligo)

CELfiles <- GSE14618_GPL570_selectedTargets$fileNames

dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE14618/"


# GSE14618_GPL570_rawData <- GSE14618_GPL570         LO DE ANTES QUE SALE BIEN


GSE14618_GPL570_rawData <- read.celfiles(file.path("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE14618/", CELfiles), phenoData = sampleInfo)


#  GSE14618_GPL570_rawData <- read.celfiles(file.path("GSE14618/", CELfiles), phenoData = sampleInfo)


colnames(exprs(GSE14618_GPL570_rawData)) <- rownames(pData(GSE14618_GPL570_rawData))
```

```{r, message=FALSE, echo=TRUE}
colores <- GSE14618_GPL570_targets$colores
grupos <- as.factor(GSE14618_GPL570_targets$grupo)
numSamples <- nrow(GSE14618_GPL570_targets)
sampleNames <- GSE14618_GPL570_targets$fileNames
```

```{r, message=FALSE, echo=TRUE}
hist(GSE14618_GPL570_rawData, main = "Distribución de valores", col = colores, lty = 1:numSamples)
legend(x = "topright", legend = sampleNames, col = colores, lty = 1:numSamples, cex = 0.6)
```

```{r, message=FALSE, echo=TRUE}
boxplot(GSE14618_GPL570_rawData, cex.axis = 0.6, col = colores, las = 2, names = sampleNames, main = "Distribución de la señal")
```

El histograma y el diagrama de caja muestran que las distribuciones de los datos son similares en formas y en posición, lo que indica que no será preciso algún tipo de centrado.

```{r, message=FALSE, echo=TRUE}
library(ggplot2)
library(ggrepel)

plotPCA3(exprs(GSE14618_GPL570_rawData), labels = sampleNames, size = 2, factor = grupos, colores = unique(colores),
    title = "PCA de las muestras", scale = TRUE)
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
dev.off()
```

La representación de los datos en las dos primeras componentes principales muestra una distribucion más o menos aleatoria. Excepto para tres GSM. [41] "GSM365153.CEL"/C23 (COG study 9404) es muy diferente al resto. El segundo más diferente al resto es el 12, GSM365124.CEL o F13 (COG study 9404). El 40, "GSM365152.CEL", o C22 (COG study 9404), también es diferente.

Un cluster jerárquico refuerza esta impresión de que no existe un agrupamiento claro de muestras. El cluster muestra que hay 6 muestras diferentes al resto, pero no tienen que ver entre sí, parece.


```{r, message=FALSE, echo=TRUE, error=TRUE}
clust.euclid.average <- hclust(dist(t(exprs(GSE14618_GPL570_rawData))), method = "average")
plot(clust.euclid.average, labels = substring(GSE14618_GPL570_rawData@phenoData@data[["shortName"]], 1, 3), main = "Hierarchical clustering of samples",
    hang = -1)
```


NR parecen más agrupados que el resto.


## Preprocesado: Control de calidad

```{r, message=FALSE, echo=TRUE, warning=FALSE}
# library(arrayQualityMetrics)
# arrayQualityMetrics(GSE14618_GPL570_rawData, outdir = "arrayQuality", intgroup = "grupo", force = TRUE)
```

No sale no se por que.

## Preprocesado: Análisis de batch

runDate proporciona la fecha de hibridación de los archivos .CEL.

```{r, message=FALSE, echo=TRUE}
GSE14618_GPL570_rawData@phenoData@data[["submission_date"]]
```

Son todas del 28 de enero de 2009. Vamos a pensar que no hay diferencias.


# GSE14618_GPL96

## Creación de un subconjunto para el análisis

```{r, message=FALSE, echo=TRUE}
dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE14618/"
archivosCel <-paste0(sampleInfo_GPL96$geo_accession, '.CEL') # 42, bien

```

```{r, message=FALSE, echo=TRUE}
(char<-GSE14618_GPL96@phenoData@data[["description"]])

shortNames <- GSE14618_GPL96@phenoData@data[["title"]]

a<-substring((GSE14618_GPL96@phenoData@data[["description"]])[1], 1, 2)

b<-substring((GSE14618_GPL96@phenoData@data[["description"]])[2:42], 1, 1)

d<- c(a,b)

cols=c()

for (valor in d){
  if (valor=="NR"){cols=append(cols, 'green2')}
  else if (valor=="F"){cols=append(cols, 'goldenrod')}
  else if (valor=="C"){cols=append(cols, 'gray')}
}
 

grup <- d

GSE14618_GPL96_targets <- data.frame(fileNames = archivosCel, shortName = shortNames, grupo = grup, colores = cols)
```

```{r, message=FALSE, echo=TRUE}


GSE14618_GPL96_selectedTargets <- GSE14618_GPL96_targets

rownames(GSE14618_GPL96_selectedTargets) <- GSE14618_GPL96_selectedTargets$shortName

table(GSE14618_GPL96_selectedTargets$grupo)

```

## Preprocesado: exploración

```{r, message=FALSE, echo=TRUE}
require(Biobase)

sampleInfo <- AnnotatedDataFrame(GSE14618_GPL96_selectedTargets)

library(oligo)

CELfiles <- GSE14618_GPL96_selectedTargets$fileNames

dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE14618/"

# GSE14618_GPL96_rawData <- GSE14618_GPL96         LO DE ANTES QUE SALE BIEN


GSE14618_GPL96_rawData <- read.celfiles(file.path("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE14618/", CELfiles), phenoData = sampleInfo)


#  GSE14618_GPL96_rawData <- read.celfiles(file.path("GSE14618/", CELfiles), phenoData = sampleInfo)


colnames(exprs(GSE14618_GPL96_rawData)) <- rownames(pData(GSE14618_GPL96_rawData))

```

```{r, message=FALSE, echo=TRUE}
colores <- GSE14618_GPL96_targets$colores
grupos <- as.factor(GSE14618_GPL96_targets$grupo)
numSamples <- nrow(GSE14618_GPL96_targets)
sampleNames <- GSE14618_GPL96_targets$fileNames
```

```{r, message=FALSE, echo=TRUE}
hist(GSE14618_GPL96_rawData, main = "Distribución de valores", col = colores, lty = 1:numSamples)
legend(x = "topright", legend = sampleNames, col = colores, lty = 1:numSamples, cex = 0.6)
```

```{r, message=FALSE, echo=TRUE}
boxplot(GSE14618_GPL96_rawData, cex.axis = 0.6, col = colores, las = 2, names = sampleNames, main = "Distribución de la señal")
```

El histograma y el diagrama de caja muestran que las distribuciones de los datos son similares en formas y en posición, lo que indica que no será preciso algún tipo de centrado.

```{r, message=FALSE, echo=TRUE}
library(ggplot2)
library(ggrepel)

plotPCA3(exprs(GSE14618_GPL96_rawData), labels = sampleNames, size = 2, factor = grupos, colores = unique(colores),
    title = "PCA de las muestras", scale = TRUE)
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
dev.off()
```

La representación de los datos en las dos primeras componentes principales muestra una distribucion más o menos aleatoria de casi todas las componentes. [33] "GSM365078.CEL"/C15 (COG study 8704) se parece poco al resto, y el que más se diferencia de las demas muestras es [5] "GSM365050.CEL"/F5 (COG study 8704)

Un cluster jerárquico refuerza esta impresión de que no existe un agrupamiento claro de muestras. Además, junto con el PCA, el cluster indica que el número 9 es distinto al resto de datos.


```{r, message=FALSE, echo=TRUE, error=TRUE}
clust.euclid.average <- hclust(dist(t(exprs(GSE14618_GPL96_rawData))), method = "average")
plot(clust.euclid.average, labels = substring(GSE14618_GPL96_rawData@phenoData@data[["shortName"]], 1, 3), main = "Hierarchical clustering of samples",
    hang = -1)

abline(h=105, col="blue", lwd=1, lty=2)
```



NR se parece sobre todo a una muestra F separada del resto, junto con otra F separada de las demás. Además, hay una muestra C alejada de todo el resto.


## Preprocesado: Control de calidad

```{r, message=FALSE, echo=TRUE, warning=FALSE}
# library(arrayQualityMetrics)
# arrayQualityMetrics(GSE14618_GPL570_rawData, outdir = "arrayQuality", intgroup = "grupo", force = TRUE)
```

No sale no se por que.

## Preprocesado: Análisis de batch

runDate proporciona la fecha de hibridación de los archivos .CEL.

```{r, message=FALSE, echo=TRUE}
GSE14618_GPL96_rawData@phenoData@data[["submission_date"]]
```

Son todas del 28 de enero de 2009. Vamos a pensar que no hay diferencias.

# GSE26713

## Creación de un subconjunto para el análisis

```{r, message=FALSE, echo=TRUE}
dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE26713/"
archivosCel <-GSE26713_getGEO@phenoData@data[["geo_accession"]] # 91
```

```{r, message=FALSE, echo=TRUE}
char<-GSE26713_getGEO@phenoData@data[["characteristics_ch1.1"]]

shortNames <- GSE26713_getGEO@phenoData@data[["title"]]

(GSE26713_getGEO@phenoData@data[["characteristics_ch1.1"]]) 

a<-substring((GSE26713_getGEO@phenoData@data[["characteristics_ch1.1"]])[1:124], 15)

d<- a

cols=c()

for (valor in d){
  if (valor=="BM"){cols=append(cols, 'firebrick2')}
  else if (valor=="HOXA"){cols=append(cols, 'deepskyblue1')}
  else if (valor=="LMO2"){cols=append(cols, 'darkolivegreen')}
  else if (valor=="TAL1"){cols=append(cols, 'darkorchid2')}
  else if (valor=="TLX3"){cols=append(cols, 'hotpink1')}
  else if (valor=="unknown"){cols=append(cols, 'coral1')}
  else if (valor=="TLX1"){cols=append(cols, 'goldenrod1')}
  else if (valor=="TAL2/LMO1"){cols=append(cols, 'dodgerblue4')}
  else if (valor=="MYB"){cols=append(cols, 'gray51')}
  else if (valor=="TAL2"){cols=append(cols, 'deeppink4')}
  else if (valor=="LMO1"){cols=append(cols, 'darksalmon')}
  else {cols=append(cols, 'burlywood4')}
}
 

grup <- d

GSE26713_targets <- data.frame(fileNames = archivosCel, shortName = shortNames, grupo = grup, colores = cols)
```

```{r, message=FALSE, echo=TRUE}

GSE26713_selectedTargets <- GSE26713_targets

rownames(GSE26713_selectedTargets) <- GSE26713_selectedTargets$shortName

table(GSE26713_selectedTargets$grupo)

```


## Preprocesado: exploración

```{r, message=FALSE, echo=TRUE}
require(Biobase)

sampleInfo <- AnnotatedDataFrame(GSE26713_selectedTargets)

library(oligo)

CELfiles <- GSE26713_selectedTargets$fileNames

setwd("datasets/GSE26713/") ## Ingresa al directorio

dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/GSE26713/"

GSE26713_rawData <- read.celfiles(list.files(pattern = ".CEL$"), phenoData = sampleInfo)

colnames(exprs(GSE26713_rawData)) <- rownames(pData(GSE26713_rawData))
```

```{r, message=FALSE, echo=TRUE}
colores <- pData(GSE26713_rawData)$colores
grupos <- as.factor(pData(GSE26713_rawData)$grupo)
numSamples <- nrow(pData(GSE26713_rawData))
sampleNames <- pData(GSE26713_rawData)$shortName
```

```{r, message=FALSE, echo=TRUE}
save(GSE26713_rawData, file = 'C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE26713/GSE26713_rawData.Rda')
```

```{r, message=FALSE, echo=TRUE}
hist(GSE26713_rawData, main = "Distribución de valores", col = colores, lty = 1:numSamples)
legend(x = "topright", legend = grupos, col = colores, lty = 1:numSamples, cex = 0.6)
```


El histograma son diferentes en formas y en posición, lo que ya indica que será preciso algún tipo de centrado.

## Preprocesado: Control de calidad

```{r, message=FALSE, echo=TRUE}
# library(arrayQualityMetrics)
# arrayQualityMetrics(GSE26713_rawData, outdir = "arrayQuality", intgroup = "grupo", force = TRUE)
```

Demasiado grande.


## Preprocesado: Análisis de batch

runDate proporciona la fecha de hibridación de los archivos .CEL.

```{r, message=FALSE, echo=TRUE}
(b<-runDate(GSE26713_rawData))
GSE26713_rawData@phenoData@data[["fileNames"]]
colnames(GSE26713_rawData@assayData[["exprs"]])
```

Hay 16 GSM, correspondientes a los 16 tipos de pacientes. El periodo de tiempo es diferencial. Es posible que haya efectos batch...



```{r PCARaw, message=FALSE, fig.cap="Visualization of the two first Principal Components for raw data"}
library(ggplot2)
library(ggrepel)
plotPCA3(exprs(GSE26713_rawData), labels = b, size = 2, factor = grupos, colores = unique(colores),
    title = "PCA de las muestras", scale = TRUE)
```

Las muestras del dia 2 parecen semejantes y distintas al resto2.


```{r, message=FALSE, echo=TRUE, error=TRUE}
clust.euclid.average <- hclust(dist(t(exprs(GSE26713_rawData))), method = "average")
plot(clust.euclid.average, labels = b, main = "Hierarchical clustering of samples",
    hang = -1)

abline(h=105, col="blue", lwd=1, lty=2)
```



# GSE28703

## Creación de un subconjunto para el análisis

```{r, message=FALSE, echo=TRUE}
dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE28703/"
archivosCel <-list.files(path = dir, pattern = "\\.CEL$")
```

```{r, message=FALSE, echo=TRUE}
library(GEOquery)
GSE28703_getGEO<-GSE28703_getGEO[[1]]
```

```{r, message=FALSE, echo=TRUE}

(shortNames <- GSE28703_getGEO@phenoData@data[["title"]])

GSE28703_getGEO@phenoData@data[["source_name_ch1"]]

cols <- c(rep("red", 7), rep("blue", 40), rep("red", 5))
# rojo: RNA extracted from diagnostic leukemic blasts of early T-cell precursor
# acute lymphoblastic leukemia, azul: RNA extracted from diagnostic leukemic blasts
# of T-cell precursor acute lymphoblastic leukemia (non-ETP)

grup <- c(rep("early T-ALL", 7), rep("non-ETP", 40),
          rep("early T-ALL", 5))

GSE28703_targets <- data.frame(fileNames = archivosCel, shortName = shortNames, grupo = grup, colores = cols)
```



```{r, message=FALSE, echo=TRUE}


GSE28703_selectedTargets <- GSE28703_targets

rownames(GSE28703_selectedTargets) <- GSE28703_selectedTargets$shortName

table(GSE28703_selectedTargets$grupo)

```

## Preprocesado: exploración

```{r, message=FALSE, echo=TRUE}
require(Biobase)

sampleInfo <- AnnotatedDataFrame(GSE28703_selectedTargets)

library(oligo)

CELfiles <- GSE28703_selectedTargets$fileNames

dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE28703/"

GSE28703_rawData <- read.celfiles(file.path(dir, CELfiles), phenoData = sampleInfo)

colnames(exprs(GSE28703_rawData)) <- rownames(pData(GSE28703_rawData))
```

```{r, message=FALSE, echo=TRUE}
colores <- pData(GSE28703_rawData)$colores
grupos <- as.factor(pData(GSE28703_rawData)$grupo)
numSamples <- nrow(pData(GSE28703_rawData))
sampleNames <- pData(GSE28703_rawData)$shortName
```

```{r, message=FALSE, echo=TRUE}
hist(GSE28703_rawData, main = "Distribución de valores", col = colores, lty = 1:numSamples)
legend(x = "topright", legend = sampleNames, col = colores, lty = 1:numSamples, cex = 0.6)
```

```{r, message=FALSE, echo=TRUE}
boxplot(GSE28703_rawData, cex.axis = 0.6, col = colores, las = 2, names = sampleNames, main = "Distribución de la señal")
```

El histograma y el diagrama de caja muestran que las distribuciones de los datos son poco similares en formas y posición, lo que ya indica que será preciso algún tipo de centrado.

```{r, message=FALSE, echo=TRUE}
library(ggplot2)
library(ggrepel)


plotPCA3(exprs(GSE28703_rawData), labels = sampleNames, size = 2, factor = grupos, colores = unique(colores),
    title = "PCA de las muestras", scale = TRUE)
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
dev.off()
```

Los datos se distribuyen al azar, parece.

Un cluster jerárquico refuerza esta impresión de que no existe un agrupamiento claro de muestras. Además, junto con el PCA, el cluster indica que el SJTALL157 es distinto al resto de datos.


```{r, message=FALSE, echo=TRUE, error=TRUE}
clust.euclid.average <- hclust(dist(t(exprs(GSE28703_rawData))), method = "average")
plot(clust.euclid.average, labels = sampleNames, main =
       "Hierarchical clustering of samples", hang = -1)
abline(h=200099, col="blue")
```

SJTALL157 es diferente al resto. SJTALL020, SJTALL001 y SJTALL009 también, pero están menos alejados de los demás. 



## Preprocesado: Control de calidad

```{r, message=FALSE, echo=TRUE}
# library(arrayQualityMetrics)
# arrayQualityMetrics(GSE28703_rawData, outdir = "arrayQuality", intgroup = "grupo", force = TRUE)
```

Hemos guardado un PDF de esto en TFM/datasets/GSE8879, llamado arrayQualityMetrics GSE8879.

## Preprocesado: Análisis de batch

runDate proporciona la fecha de hibridación de los archivos .CEL.

```{r, message=FALSE, echo=TRUE}
library(oligo)
(b<-runDate(GSE28703_rawData))
GSE28703_rawData@phenoData@data[["fileNames"]]
colnames(GSE28703_rawData@assayData[["exprs"]])
```

Hay 16 GSM, correspondientes a los 16 tipos de pacientes. El periodo de tiempo es diferencial. No creemos que haya batch por las horas.



```{r PCARaw, message=FALSE, fig.cap="Visualization of the two first Principal Components for raw data"}
library(ggplot2)
library(ggrepel)

plotPCA3(exprs(GSE28703_rawData), labels = b, size = 2, factor = grupos, colores = unique(colores),
    title = "PCA de las muestras", scale = TRUE)
```

Las muestras parecen que se distribuyen aleatoriamente.


# GSE32215

## Creación de un subconjunto para el análisis

```{r, message=FALSE, echo=TRUE}
dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE32215/"
archivosCel <-GSE32215_getGEO[["GSE32215_series_matrix.txt.gz"]]@phenoData@data[["geo_accession"]] # 228
```

```{r, message=FALSE, echo=TRUE}
char<-GSE32215_getGEO[["GSE32215_series_matrix.txt.gz"]]@phenoData@data[["characteristics_ch1"]] 

shortNames <- GSE32215_getGEO[["GSE32215_series_matrix.txt.gz"]]@phenoData@data[["title"]]

(GSE32215_getGEO[["GSE32215_series_matrix.txt.gz"]]@phenoData@data[["characteristics_ch1"]]) 
 

d<- GSE32215_getGEO[["GSE32215_series_matrix.txt.gz"]]@phenoData@data[["cell type:ch1"]]

cols=c()

for (valor in d){
  if (valor=="adult T-ALL"){cols=append(cols, 'red')}
  else if (valor=="pediatric T-ALL"){cols=append(cols, 'blue')}
  else if (valor=="unknown"){cols=append(cols, 'goldenrod1')}
}
 

grup <- d

GSE32215_targets <- data.frame(fileNames = archivosCel, shortName = shortNames, grupo = grup, colores = cols)
```


```{r, message=FALSE, echo=TRUE}

GSE32215_selectedTargets <- GSE32215_targets

rownames(GSE32215_selectedTargets) <- GSE32215_selectedTargets$shortName

table(GSE32215_selectedTargets$grupo)

```

## Preprocesado: exploración

```{r, message=FALSE, echo=TRUE}
require(Biobase)

sampleInfo <- AnnotatedDataFrame(GSE32215_selectedTargets)

library(oligo)

CELfiles <- GSE32215_selectedTargets$fileNames

setwd("datasets/GSE32215/") ## Ingresa al directorio

dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/GSE32215/"

GSE32215_rawData <- read.celfiles(list.files(pattern = ".CEL$"), phenoData = sampleInfo)

colnames(exprs(GSE32215_rawData)) <- rownames(pData(GSE32215_rawData))
```

```{r, message=FALSE, echo=TRUE}
colores <- pData(GSE32215_rawData)$colores
grupos <- as.factor(pData(GSE32215_rawData)$grupo)
numSamples <- nrow(pData(GSE32215_rawData))
sampleNames <- pData(GSE32215_rawData)$shortName
```

```{r, message=FALSE, echo=TRUE}
hist(GSE32215_rawData, main = "Distribución de valores", col = colores, lty = 1:numSamples)
legend(x = "topright", legend = sampleNames, col = colores, lty = 1:numSamples, cex = 0.6)
```



El histograma y el diagrama de caja muestran que las distribuciones de los datos son poco similares en formas y posición, lo que ya indica que será preciso algún tipo de centrado.

```{r, message=FALSE, echo=TRUE}
library(ggplot2)
library(ggrepel)


plotPCA3(exprs(GSE32215_rawData), labels = substring(sampleNames, 16), size = 2, factor = grupos, colores = unique(colores),
    title = "PCA de las muestras", scale = TRUE)
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
dev.off()
```

Nos datos pedriáicos se definen en tres grupos. En uno se sitúan el resto de muestras de adulto.


```{r, message=FALSE, echo=TRUE, error=TRUE}
clust.euclid.average <- hclust(dist(t(exprs(GSE32215_rawData))), method = "average")
plot(clust.euclid.average, labels = substring(sampleNames, 16), main =
       "Hierarchical clustering of samples", hang = -1)
abline(h=200099, col="blue")
```

## Preprocesado: Control de calidad

No se ha podido hacer.


```{r, message=FALSE, echo=TRUE, warning=FALSE}
# library(arrayQualityMetrics)
# arrayQualityMetrics(GSE32215_rawData, outdir = "arrayQuality", intgroup = "grupo", force = TRUE)
```


## Preprocesado: Análisis de batch

runDate proporciona la fecha de hibridación de los archivos .CEL.

```{r, message=FALSE, echo=TRUE}
(b<-runDate(GSE32215_rawData))
GSE32215_rawData@phenoData@data[["fileNames"]]
colnames(GSE32215_rawData@assayData[["exprs"]])
```

Las fechas son muy distintas. Posible efecto batch.

# GSE33469

## Creación de un subconjunto para el análisis

```{r, message=FALSE, echo=TRUE}
dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE33469/"
archivosCel <-GSE33469_getGEO@phenoData@data[["geo_accession"]] # 57
```

```{r, message=FALSE, echo=TRUE}
char<-GSE33469_getGEO@phenoData@data[["characteristics_ch1"]] 

shortNames <- GSE33469_getGEO@phenoData@data[["title"]]

(GSE33469_getGEO@phenoData@data[["characteristics_ch1"]]) 

d<- substring(GSE33469_getGEO@phenoData@data[["title"]], 15)

cols=rep('red', 57)
 

grup <- d

GSE33469_targets <- data.frame(fileNames = archivosCel, shortName = shortNames, grupo = grup, colores = cols)
```

Aqui solo tenemos un grupo.

```{r, message=FALSE, echo=TRUE}

GSE33469_selectedTargets <- GSE33469_targets

rownames(GSE33469_selectedTargets) <- GSE33469_selectedTargets$shortName

table(GSE33469_selectedTargets$grupo)

```


```{r, message=FALSE, echo=TRUE}

GSE33469_selectedTargets <- GSE33469_targets

rownames(GSE33469_selectedTargets) <- GSE33469_selectedTargets$shortName

table(GSE33469_selectedTargets$grupo)

library(oligo)

sampleInfo <- AnnotatedDataFrame(GSE33469_selectedTargets)


#GSE33469_rawData <- read.celfiles(file.path("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE33469", CELfiles), phenoData = sampleInfo)

GSE33469_getGEO@phenoData<-sampleInfo

GSE33469_rawData<-GSE33469_getGEO

colnames(exprs(GSE33469_rawData)) <- rownames(pData(GSE33469_rawData))

```





## Preprocesado: exploración

```{r, message=FALSE, echo=TRUE}
require(Biobase)

sampleInfo <- AnnotatedDataFrame(GSE33469_selectedTargets)

library(oligo)

CELfiles <- GSE33469_selectedTargets$fileNames

setwd("datasets/GSE33469/") ## Ingresa al directorio

dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/GSE33469/"



GSE33469_rawData <- GSE33469_getGEO


GSE33469_rawData@phenoData=sampleInfo

colnames(exprs(GSE33469_rawData)) <- rownames(pData(GSE33469_rawData))
```

```{r, message=FALSE, echo=TRUE}
colores <- pData(GSE33469_rawData)$colores
grupos <- as.factor(pData(GSE33469_rawData)$grupo)
numSamples <- nrow(pData(GSE33469_rawData))
sampleNames <- pData(GSE33469_rawData)$shortName
```

```{r, message=FALSE, echo=TRUE}
hist(GSE33469_rawData, main = "Distribución de valores", col = colores, lty = 1:numSamples)
legend(x = "topright", legend = sampleNames, col = colores, lty = 1:numSamples, cex = 0.6)
```

```{r, message=FALSE, echo=TRUE}
boxplot(GSE33469_rawData, cex.axis = 0.6, col = colores, las = 2, names = sampleNames, main = "Distribución de la señal")
```

El histograma y el diagrama de caja muestran que las distribuciones de los datos son similares en formas y en posición. No hará falta centrado.

```{r, message=FALSE, echo=TRUE}

plotPCA3(exprs(GSE33469_rawData), labels = sampleNames, size = 2, factor = grupos, colores = colores,
    title = "PCA de las muestras", scale = TRUE, options(ggrepel.max.overlaps = Inf))
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
dev.off()
```

La representación de los datos en las dos primeras componentes principales muestra cierta separación a lo largo de la segunda componente, aunque no queda claro por qué se distribuyen así.

La primera componente, en cambio, es más difícil de interpretar.

Un cluster jerárquico refuerza esta impresión de que no existe un agrupamiento claro de muestras. Además, junto con el PCA, el cluster indica que el número 9 es distinto al resto de datos.


```{r, message=FALSE, echo=TRUE, error=TRUE}
clust.euclid.average <- hclust(dist(t(exprs(GSE33469_rawData))), method = "average")
plot(clust.euclid.average, labels = grupos, main = "Hierarchical clustering of samples",
    hang = -1)

```

La muestra del paciente 12 es la que menos se parece a las demás, pero como hemos visto se parecen mucho entre ellas.



## Preprocesado: Control de calidad

```{r, message=FALSE, echo=TRUE, warning=FALSE}
# library(arrayQualityMetrics)
# arrayQualityMetrics(GSE33469_rawData, outdir = "arrayQuality", intgroup = "grupo", force = TRUE)
```

Hemos guardado un PDF de esto en TFM/datasets/GSE33469, llamado arrayQualityMetrics GSE33469.

## Preprocesado: Análisis de batch

runDate proporciona la fecha de hibridación de los archivos .CEL.

```{r, message=FALSE, echo=TRUE, error=TRUE}
(b<-runDate(GSE33469_rawData))
GSE33469_rawData@phenoData@data[["fileNames"]]
colnames(GSE33469_rawData@assayData[["exprs"]])
```

Es posible que haya efectos batch...

# GSE33470
## Creación de un subconjunto para el análisis

```{r, message=FALSE, echo=TRUE}
dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE33470/"
archivosCel <-GSE33470_getGEO@phenoData@data[["geo_accession"]] # 21
```

```{r, message=FALSE, echo=TRUE}
char<-GSE33470_getGEO@phenoData@data[["characteristics_ch1"]] 

shortNames <- GSE33470_getGEO@phenoData@data[["title"]]

(GSE33470_getGEO@phenoData@data[["t-cell population:ch1"]]) 

d<- GSE33470_getGEO@phenoData@data[["t-cell population:ch1"]]

cols=c()

for (valor in d){
  if (valor=="CD3+CD4+"){cols=append(cols, 'chartreuse4')}
  else if (valor=="CD3+CD8+"){cols=append(cols, 'aquamarine2')}
  else if (valor=="CD34+CD1a-"){cols=append(cols, 'blue4')}
  else if (valor=="CD34+CD1a+"){cols=append(cols, 'darkgray')}
  else if (valor=="CD4ISP"){cols=append(cols, 'darkorange')}
  else if (valor=="DPCD3-"){cols=append(cols, 'red1')}
  else {cols=append(cols, 'palevioletred2')}
}
 

grup <- d

GSE33470_targets <- data.frame(fileNames = archivosCel, shortName = shortNames, grupo = grup, colores = cols)
```


```{r, message=FALSE, echo=TRUE}

GSE33470_selectedTargets <- GSE33470_targets

rownames(GSE33470_selectedTargets) <- GSE33470_selectedTargets$shortName

table(GSE33470_selectedTargets$grupo)

```

## Preprocesado: exploración

```{r, message=FALSE, echo=TRUE}
require(Biobase)

sampleInfo <- AnnotatedDataFrame(GSE33470_selectedTargets)

library(oligo)

CELfiles <- GSE33470_selectedTargets$fileNames

setwd("datasets/GSE33470/") ## Ingresa al directorio

dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/GSE33470/"

GSE33470_rawData <- GSE33470_getGEO

GSE33470_rawData@phenoData <- sampleInfo

colnames(exprs(GSE33470_rawData)) <- rownames(pData(GSE33470_rawData))
```

```{r, message=FALSE, echo=TRUE}
colores <- pData(GSE33470_rawData)$colores
grupos <- as.factor(pData(GSE33470_rawData)$grupo)
numSamples <- nrow(pData(GSE33470_rawData))
sampleNames <- pData(GSE33470_rawData)$shortName
```

```{r, message=FALSE, echo=TRUE}
hist(GSE33470_rawData, main = "Distribución de valores", col = colores, lty = 1:numSamples)
legend(x = "topright", legend = sampleNames, col = colores, lty = 1:numSamples, cex = 0.6)
```

```{r, message=FALSE, echo=TRUE}
boxplot(GSE33470_rawData, cex.axis = 0.6, col = colores, las = 2, names = sampleNames, main = "Distribución de la señal")
```

El histograma y el diagrama de caja muestran que las distribuciones de los datos son similares en formas y en posición, por lo que no requieren centrado.

```{r, message=FALSE, echo=TRUE}

plotPCA3(exprs(GSE33470_rawData), labels = sampleNames, size = 2, factor = grupos, colores = unique(colores),
    title = "PCA de las muestras", scale = TRUE, options(ggrepel.max.overlaps = Inf))
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
dev.off()
```

No hay una tendencia clara, pero CD34+CD1a+ rep 2 es muy distinto con respecto al resto. Es verdad que las muestras de CD4IDP se parecen más entre sí también.


```{r, message=FALSE, echo=TRUE, error=TRUE}
clust.euclid.average <- hclust(dist(t(exprs(GSE33470_rawData))), method = "average")
plot(clust.euclid.average, labels = sampleNames, main = "Hierarchical clustering of samples",
    hang = -1)

```

Las muestras se parecen poco entre si en general.

## Preprocesado: Control de calidad

```{r, message=FALSE, echo=TRUE, warning=FALSE}
# library(arrayQualityMetrics)
# arrayQualityMetrics(GSE33470_rawData, outdir = "arrayQuality", intgroup = "grupo", force = TRUE)
```

Hemos guardado un PDF de esto en TFM/datasets/GSE33470, llamado arrayQualityMetrics GSE33470.

## Preprocesado: Análisis de batch

runDate proporciona la fecha de hibridación de los archivos .CEL.

```{r, message=FALSE, echo=TRUE, error=TRUE}
(b<-runDate(GSE33470_rawData))
GSE33470_rawData@phenoData@data[["fileNames"]]
colnames(GSE33470_rawData@assayData[["exprs"]])
```

Es posible que haya efectos batch...




# GSE37389

## Creación de un subconjunto para el análisis

```{r, message=FALSE, echo=TRUE}
dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE33470/"
archivosCel <-GSE37389_getGEO@phenoData@data[["geo_accession"]] # 14
```

```{r, message=FALSE, echo=TRUE}
char<-GSE37389_getGEO@phenoData@data[["characteristics_ch1"]] 

(shortNames <- GSE37389_getGEO@phenoData@data[["title"]])

# TCR-GD indica TCR gamma delta T-ALL. TCR-AB es alfa beta

(GSE37389_getGEO@phenoData@data[["characteristics_ch1"]]) 

d<- substring(GSE37389_getGEO@phenoData@data[["title"]], 5, 10)

cols=c()

for (valor in d){
  if (valor=="TCR-AB"){cols=append(cols, 'red')}
  else if (valor=="TCR-GD"){cols=append(cols, 'blue')}
  else {cols=append(cols, 'goldenrod1')}
}
 

grup <- d

GSE37389_targets <- data.frame(fileNames = archivosCel, shortName = shortNames, grupo = grup, colores = cols)
```


```{r, message=FALSE, echo=TRUE}

GSE37389_selectedTargets <- GSE37389_targets

rownames(GSE37389_selectedTargets) <- GSE37389_selectedTargets$shortName

table(GSE37389_selectedTargets$grupo)

```

## Preprocesado: exploración

```{r, message=FALSE, echo=TRUE}
require(Biobase)

sampleInfo <- AnnotatedDataFrame(GSE37389_selectedTargets)

library(oligo)

CELfiles <- GSE37389_selectedTargets$fileNames

setwd("datasets/GSE37389/") ## Ingresa al directorio

GSE37389_rawData <- GSE37389_getGEO

GSE37389_rawData@phenoData<-sampleInfo

colnames(exprs(GSE37389_rawData)) <- rownames(pData(GSE37389_rawData))
```

```{r, message=FALSE, echo=TRUE}
colores <- pData(GSE37389_rawData)$colores
grupos <- as.factor(pData(GSE37389_rawData)$grupo)
numSamples <- nrow(pData(GSE37389_rawData))
sampleNames <- pData(GSE37389_rawData)$shortName
```

```{r, message=FALSE, echo=TRUE}
hist(GSE37389_rawData, main = "Distribución de valores", col = colores, lty = 1:numSamples)
legend(x = "topright", legend = sampleNames, col = colores, lty = 1:numSamples, cex = 0.6)
```

```{r, message=FALSE, echo=TRUE}
boxplot(GSE37389_rawData, cex.axis = 0.6, col = colores, las = 2, names = sampleNames, main = "Distribución de la señal")
```

El histograma y el diagrama de caja muestran que será preciso algún tipo de centrado.

```{r, message=FALSE, echo=TRUE}

plotPCA3(exprs(GSE37389_rawData), labels = sampleNames, size = 2, factor = grupos, colores = unique(colores),
    title = "PCA de las muestras", scale = TRUE, options(ggrepel.max.overlaps = Inf))
```

A3 es el que más variablidad aporta, junto con G4.

```{r, message=FALSE, echo=TRUE, error=TRUE}
dev.off()
```

La representación de los datos en las dos primeras componentes principales muestra cierta separación a lo largo de la segunda componente, aunque no queda claro por qué se distribuyen así.

La primera componente, en cambio, es más difícil de interpretar.

Un cluster jerárquico refuerza esta impresión de que no existe un agrupamiento claro de muestras. Además, junto con el PCA, el cluster indica que el número 9 es distinto al resto de datos.


```{r, message=FALSE, echo=TRUE, error=TRUE}
clust.euclid.average <- hclust(dist(t(exprs(GSE37389_rawData))), method = "average")
plot(clust.euclid.average, labels = sampleNames, main = "Hierarchical clustering of samples",
    hang = -1)

```

G4 es el más diferente al resto. Depués hay un pequeño subgrupo con A1, G1 y A2.

## Preprocesado: Control de calidad

```{r, message=FALSE, echo=TRUE, warning=FALSE}
# library(arrayQualityMetrics)
# arrayQualityMetrics(GSE37389_rawData, outdir = "arrayQuality", intgroup = "grupo", force = TRUE)
```

Hemos guardado un PDF de esto en TFM/datasets/GSE37389, llamado arrayQualityMetrics GSE37389. 

## Preprocesado: Análisis de batch

runDate proporciona la fecha de hibridación de los archivos .CEL.

```{r, message=FALSE, echo=TRUE, error=TRUE}
(b<-runDate(GSE37389_rawData))
GSE37389_rawData@phenoData@data[["fileNames"]]
colnames(GSE37389_rawData@assayData[["exprs"]])
```

Es posible que haya efectos batch...



```{r PCARaw, message=FALSE, fig.cap="Visualization of the two first Principal Components for raw data"}
# library(ggplot2)
# library(ggrepel)
# plotPCA3(exprs(GSE37389_rawData), labels = b, size = 2, factor = substring(b, 9), colores = unique(colores),
    # title = "PCA de las muestras", scale = TRUE)
```



# GSE56488


## Creación de un subconjunto para el análisis

```{r, message=FALSE, echo=TRUE}
dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE56488/"
archivosCel <-GSE56488_getGEO[["GSE56488_series_matrix.txt.gz"]]@phenoData@data[["geo_accession"]] # 91
```

```{r, message=FALSE, echo=TRUE}
char<-GSE56488_getGEO[["GSE56488_series_matrix.txt.gz"]]@phenoData@data[["characteristics_ch1"]] 

shortNames <- GSE56488_getGEO[["GSE56488_series_matrix.txt.gz"]]@phenoData@data[["title"]]

(GSE56488_getGEO[["GSE56488_series_matrix.txt.gz"]]@phenoData@data[["characteristics_ch1"]]) 

d=c()
for (i in 1:16){d<-append(d, paste0('muestra', i))}

cols=rep('red', 16)
 

grup <- d

GSE56488_targets <- data.frame(fileNames = archivosCel, shortName = shortNames, grupo = grup, colores = cols)
```


```{r, message=FALSE, echo=TRUE}

GSE56488_selectedTargets <- GSE56488_targets

rownames(GSE56488_selectedTargets) <- GSE56488_selectedTargets$shortName

table(GSE56488_selectedTargets$grupo)

```

## Preprocesado: exploración

```{r, message=FALSE, echo=TRUE}
require(Biobase)

sampleInfo <- AnnotatedDataFrame(GSE56488_selectedTargets)

library(oligo)

CELfiles <- GSE56488_selectedTargets$fileNames

setwd("datasets/GSE56488/") ## Ingresa al directorio

dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/GSE56488/"

GSE56488_rawData <- read.celfiles(list.files(pattern = ".CEL$"), phenoData = sampleInfo)

colnames(exprs(GSE56488_rawData)) <- rownames(pData(GSE56488_rawData))
```

```{r, message=FALSE, echo=TRUE}
colores <- pData(GSE56488_rawData)$colores
grupos <- as.factor(pData(GSE56488_rawData)$grupo)
numSamples <- nrow(pData(GSE56488_rawData))
sampleNames <- pData(GSE56488_rawData)$shortName
```

```{r, message=FALSE, echo=TRUE}
hist(GSE56488_rawData, target="core", main = "Distribución de valores", col = colores, lty = 1:numSamples)
legend(x = "topright", legend = sampleNames, col = colores, lty = 1:numSamples, cex = 0.6)
```

```{r, message=FALSE, echo=TRUE}
boxplot(GSE56488_rawData, target="core", cex.axis = 0.6, col = colores, las = 2, names = sampleNames, main = "Distribución de la señal")
```

El histograma y el diagrama de caja muestran que las distribuciones de los datos son similares en formas pero no del todo en posición, lo que ya indica que tal vez será preciso algún tipo de centrado.


Un cluster jerárquico refuerza esta impresión de que no existe un agrupamiento claro de muestras. Además,la muestra 5 y 9 se parecen mas entre si y estan alejadas del resto de los datos.

```{r, message=FALSE, echo=TRUE, error=TRUE}
clust.euclid.average <- hclust(dist(t(exprs(GSE56488_rawData))), method = "average")
plot(clust.euclid.average, labels = grupos, main = "Hierarchical clustering of samples",
    hang = -1)

```

Las muestras se parecen poco entre si en general.

## Preprocesado: Control de calidad

```{r, message=FALSE, echo=TRUE, warning=FALSE}
# library(arrayQualityMetrics)
# arrayQualityMetrics(GSE56488_rawData, outdir = "arrayQuality", intgroup = "grupo", force = TRUE)
```

Hemos guardado un PDF de esto en TFM/datasets/GSE56488, llamado arrayQualityMetrics GSE56488.

## Preprocesado: Análisis de batch

runDate proporciona la fecha de hibridación de los archivos .CEL.

```{r, message=FALSE, echo=TRUE}
(b<-runDate(GSE56488_rawData))
GSE56488_rawData@phenoData@data[["fileNames"]]
colnames(GSE56488_rawData@assayData[["exprs"]])
```

Hay 16 GSM, correspondientes a los 16 pacientes. El periodo de tiempo es muy parecido. No pensamos que haya efect batch.



```{r PCARaw, message=FALSE, fig.cap="Visualization of the two first Principal Components for raw data"}
library(ggplot2)
library(ggrepel)
plotPCA3(exprs(GSE56488_rawData), labels = grupos, size = 2, factor = substring(b, 9), colores = (colores),
    title = "PCA de las muestras", scale = TRUE)
```

Hay una muestra que se parece menos al resto, pero no parece tener que ver con la hora.


# GSE62156


## Creación de un subconjunto para el análisis

```{r, message=FALSE, echo=TRUE}
dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE62156/"
archivosCel <-GSE62156_getGEO[["GSE62156_series_matrix.txt.gz"]]@phenoData@data[["geo_accession"]] # 64
```

```{r, message=FALSE, echo=TRUE}
char<-GSE62156_getGEO[["GSE62156_series_matrix.txt.gz"]]@phenoData@data[["characteristics_ch1"]] 

shortNames <- substring(GSE62156_getGEO[["GSE62156_series_matrix.txt.gz"]]@phenoData@data[["title"]], 1, 7)

(GSE62156_getGEO[["GSE62156_series_matrix.txt.gz"]]@phenoData@data[["characteristics_ch1"]]) 

a<-c('TAL-R', 'immature', 'TLX3', 'immature', 'immature', 'CALM-AF10', 'immature', 'TAL-R', 'TLX3', 'TLX3', 'MLL-t', 'TAL-R', 'TAL-R', 'HOX', 'TAL-R', 'TAL-R', 'immature', 'immature, HOXA13-t', 'TLX3', 'immature', 'TAL-R', 'immature', 'HOXA of unknown mechanism', 'TAL-R', 'TAL-R', 'TLX3', 'immature', 'TLX3', 'immature', 'immature', 'TLX1', 'TAL-R', 'immature', 'TAL-R', 'MLL-t', 'TAL-R', 'TLX1', 'immature', 'TLX3', 'unknown', 'TAL-R', 'TAL-R', 'TAL-R', 'TAL-R', 'TLX3', 'immature', rep('TAL-R', 8), 'TLX1', 'TLX1', 'TLX3', 'TLX3', 'TLX3', 'TLX1', 'MLL-t', 'TLX3', 'immature, HOXA13-t', 'TAL-R') # FALTA UNO




cols=c()

for (valor in a){
  if (valor=="CALM-AF10"){cols=append(cols, 'red')}
  else if (valor=="HOX"){cols=append(cols, 'blue')}
  else if (valor=="HOXA of unknown mechanism"){cols=append(cols, 'black')}
  else if (valor=="immature"){cols=append(cols, 'purple')}
  else if (valor=="immature, HOXA13-t"){cols=append(cols, 'green')}
  else if (valor=="MLL-t"){cols=append(cols, 'pink')}
  else if (valor=="TAL-R"){cols=append(cols, 'lightgoldenrod2')}
  else if (valor=="TLX1"){cols=append(cols, 'forestgreen')}
  else if (valor=="TLX3"){cols=append(cols, 'blueviolet')}
  else if (valor=="unknown"){cols=append(cols, 'azure4')}
  else {cols=append(cols, 'goldenrod1')}
}
 

grup <- a

GSE62156_targets <- data.frame(fileNames = archivosCel, shortName = shortNames, grupo = grup, colores = cols)
```


```{r, message=FALSE, echo=TRUE}

GSE62156_selectedTargets <- GSE62156_targets

rownames(GSE62156_selectedTargets) <- GSE62156_selectedTargets$shortName

table(GSE62156_selectedTargets$grupo)

```

## Preprocesado: exploración

```{r, message=FALSE, echo=TRUE}
require(Biobase)

sampleInfo <- AnnotatedDataFrame(GSE62156_selectedTargets)

library(oligo)

CELfiles <- GSE62156_selectedTargets$fileNames

setwd("datasets/GSE62156/") ## Ingresa al directorio

dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/GSE62156/"

GSE62156_rawData <- read.celfiles(list.files(pattern = ".CEL$"), phenoData = sampleInfo)

colnames(exprs(GSE62156_rawData)) <- rownames(pData(GSE62156_rawData))
```

```{r, message=FALSE, echo=TRUE}
colores <- pData(GSE62156_rawData)$colores
grupos <- as.factor(pData(GSE62156_rawData)$grupo)
numSamples <- nrow(pData(GSE62156_rawData))
sampleNames <- pData(GSE62156_rawData)$shortName
```

```{r, message=FALSE, echo=TRUE}
hist(GSE62156_rawData, main = "Distribución de valores", col = colores, lty = 1:numSamples)
legend(x = "topright", legend = sampleNames, col = colores, lty = 1:numSamples, cex = 0.6)
```

```{r, message=FALSE, echo=TRUE}
boxplot(GSE62156_rawData, cex.axis = 0.6, col = colores, las = 2, names = sampleNames, main = "Distribución de la señal")
```

El histograma y el diagrama de caja muestran que hay dos distribuciones de datos parecidas, pero no mucho entre sí.

```{r, message=FALSE, echo=TRUE}

plotPCA3(exprs(GSE62156_rawData), labels = sampleNames, size = 2, factor = grupos, colores = unique(colores),
    title = "PCA de las muestras", scale = TRUE, options(ggrepel.max.overlaps = Inf))
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
dev.off()
```

Parece que ciertos datos en verde claro son más pareidos entre sí (TAL-R), al igual que pasa con ciertos rojos (immature) y los rosas (immature, HOXA13-t).

Un cluster jerárquico refuerza esta impresión de que no existe un agrupamiento claro de muestras. Además, junto con el PCA, el cluster indica que el número 9 es distinto al resto de datos.


```{r, message=FALSE, echo=TRUE, error=TRUE}
clust.euclid.average <- hclust(dist(t(exprs(GSE62156_rawData))), method = "average")
plot(clust.euclid.average, labels = grupos, main = "Hierarchical clustering of samples",
    hang = -1)

```

Las muestras se parecen entre si más o menos igual en general, según el clúster.

## Preprocesado: Control de calidad

```{r, message=FALSE, echo=TRUE, warning=FALSE}
# library(arrayQualityMetrics)
# arrayQualityMetrics(GSE10609_rawData, outdir = "arrayQuality", intgroup = "grupo", force = TRUE)
```

Hemos guardado un PDF de esto en TFM/datasets/GSE10609, llamado arrayQualityMetrics GSE10609.

## Preprocesado: Análisis de batch

runDate proporciona la fecha de hibridación de los archivos .CEL.

```{r, message=FALSE, echo=TRUE}
(b<-runDate(GSE62156_rawData))
GSE62156_rawData@phenoData@data[["fileNames"]]
colnames(GSE62156_rawData@assayData[["exprs"]])
```

Hay 64 GSM, correspondientes a los 64 pacientes. El periodo de tiempo es diferencial. Es posible que haya efectos batch...



```{r PCARaw, message=FALSE, fig.cap="Visualization of the two first Principal Components for raw data"}
library(ggplot2)
library(ggrepel)
plotPCA3(exprs(GSE62156_rawData), labels = b, size = 2, factor = substring(b, 1, 8), colores = colores,
    title = "PCA de las muestras", scale = TRUE)
```

Los colores morados  están más alejados del resto, e igual algunos rojos. Los demás grupos, 9 grupos, se parecen más entre sí. Las muestras del mismo día se parecen más entre sí...Pensamos que puede haber efecto batch...

# Preprocesado 1. Datos de RNA-seq

El workflow es diferente para los datos de RNA-seq. Aquí empezaremos con algunos pasos. Ya realizamos la lectura de la matriz de contajes. A continuación se muestran algunos datos de preprocesado.

# GSE110633

## Estandarización de los contajes

Los datos de secuenciación pueden estar “desbalanceados” en el sentido que distintas muestras pueden contener un número distinto de secuencias, lo que puede inducir erróneamente a pensar que un gen se expresa más en una muestra que en otra, cuando esto se deba a esta diferencia global.

Esto puede evitarse expresando los contajes como “CPMs” es decir “counts per million”, lo que no modificará los resultados de comparaciones posteriores, pero hará que las muestras sean comparables en número, lo que es útil y necesario para los análisis posteriores.

```{r, echo=TRUE, warning=TRUE, error=FALSE}
library(edgeR)
GSE110633_selectedCounts[1:5, 1:6]
```

```{r, echo=TRUE, warning=TRUE, error=FALSE}
apply(GSE110633_selectedCounts, 2, sum)
GSE110633_counts.CPM <- cpm(GSE110633_selectedCounts)
GSE110633_counts.CPM[1:5, 1:6]
apply(GSE110633_counts.CPM, 2, sum)
```

## Filtraje de genes poco expresados

Los genes con recuentos muy bajos en todas las librerías (es decir en todas las muestras) proporcionan poca evidencia de expresión diferencial, por lo que es habitual eliminar aquellos genes que, o bien varían muy poco entre grupos, o bien presentan poca o nula expresión en la mayoría de las muestras.

En este caso, siguiendo un criterio habitual, se opta por conservar únicamente aquellos genes que presentan algún valor en, al menos, *tres muestras de cada grupo*.


```{r, echo=TRUE, warning=TRUE, error=FALSE}
thresh <- GSE110633_counts.CPM > 0
keep <- (rowSums(thresh[, 1:10]) >= 3) & (rowSums(thresh[, 11:20]) >= 3)
GSE110633_counts.keep <- GSE110633_counts.CPM[keep, ]
dim(GSE110633_counts.CPM)
dim(GSE110633_counts.keep)
```

Aunque no sea más que un ejemplo basta con ver los dos primeros genes para comprobar como el primero no cumple la condición, en el grupo “SANO”, mientras que los siguientes sí que la cumplen. Por lo tanto, al filtrar desaparece el primer gen de la matriz filtrada, pero no los dos siguientes.


```{r, echo=TRUE, warning=TRUE, error=FALSE}
round(head(GSE110633_counts.CPM), 3)
round(head(GSE110633_counts.keep), 3)
```


## Uso de clases específicas para manejar los datos
Cuando se trabaja con distintos objetos referidos a unos mismos datos, como la matriz de contajes y el objeto “targets”, es útil disponer de contenedores que permitan trabajar con todos ellos a la vez, lo que no sólo facilita el trabajo sino que ayuda a evitar “desincronizaciones”.

Éste es el caso de la clase ExpressionSet habitualmente utilizada con microarrays o de la clase que la generaliza, llamada SummarizedExperiment.

Para datos de contaje es habitual usar una clase similar a ExpressionSet llamada DGEList” pensadas para manejar datos de contajes , definida en el paquete edgeR. Esta clase, más simple que las anteriores, utiliza listas para almacenar recuentos de “reads” e información asociada de tecnologías de secuenciación. Puede encontrarse información al respecto en la ayuda del paquete edgeR.


```{r, echo=TRUE, warning=TRUE, error=FALSE}
GSE110633_dgeObj <- DGEList(counts = GSE110633_counts.keep, lib.size = colSums(GSE110633_counts.keep), norm.factors = rep(1,
    ncol(GSE110633_counts.keep)), samples = GSE110633_selectedTargets, group = GSE110633_selectedTargets$group,
    genes = rownames(GSE110633_counts.keep), remove.zeros = FALSE)
show(GSE110633_dgeObj)
```

Aunque podríamos haber creado el objeto a partir de todas las muestras, y haber realizado la extracción de genes y muestras posteriormente, hemos optado por no hacerlo para facilitar el seguimiento del proceso.

Luego se hace la normalización, transfromación logarítmica....


# GSE110636

## Estandarización de los contajes


```{r, echo=TRUE, warning=TRUE, error=FALSE}
library(edgeR)
GSE110636_selectedCounts[1:5, 1:6]
```

```{r, echo=TRUE, warning=TRUE, error=FALSE}
apply(GSE110636_selectedCounts, 2, sum)
GSE110636_counts.CPM <- cpm(GSE110636_selectedCounts)
GSE110636_counts.CPM[1:5, 1:6]
apply(GSE110636_counts.CPM, 2, sum)
```

## Filtraje de genes poco expresados


```{r, echo=TRUE, warning=TRUE, error=FALSE}
thresh <- GSE110636_counts.CPM > 0
keep <- (rowSums(thresh[, 1:10]) >= 3) & (rowSums(thresh[, 11:20]) >= 3)
GSE110636_counts.keep <- GSE110636_counts.CPM[keep, ]
dim(GSE110636_counts.CPM)
dim(GSE110636_counts.keep)
```




```{r, echo=TRUE, warning=TRUE, error=FALSE}
round(head(GSE110636_counts.CPM), 3)
round(head(GSE110636_counts.keep), 3)
```


## Uso de clases específicas para manejar los datos



```{r, echo=TRUE, warning=TRUE, error=FALSE}
GSE110636_dgeObj <- DGEList(counts = GSE110636_counts.keep, lib.size = colSums(GSE110636_counts.keep), norm.factors = rep(1,
    ncol(GSE110636_counts.keep)), samples = GSE110636_selectedTargets, group = GSE110636_selectedTargets$group,
    genes = rownames(GSE110636_counts.keep), remove.zeros = FALSE)
show(GSE110636_dgeObj)
```


Luego se hace la normmalización, transfromación logarítmica....






# Preprocesado 2. Datos de microarrays

Aquí haremos la continuación de la normalización: el filtraje y anotación de cada objeto creado. Todo ello a partir de los datos. Como hay ciertos datos que ya han sido normalizados y filtrados, seguiremos con el filtrado. Solo habíamos filtrado los genes nulos. Ahora haremos más.

# GSE8879

Hicimos: 

GSE8879_rawData <- read.celfiles(file.path(dir, CELfiles), phenoData = sampleInfo)

## Normalización y filtraje

Seguimos con otro filtrado. El filtraje no específico permite eliminar los genes que varían poco entre condiciones o que deseamos quitar por otras razones como por ejemplo que no disponemos de anotación para ellos. La función nsFilter permite eliminar los genes que, o bien varían poco, o bien no se dispone de anotación para ellos. Si al filtrar deseamos usar las anotaciones, o la falta de ellas, como criterio de filtraje debemos disponer del correspondiente paquete de anotaciones.

Si al crear el objeto expressionSet no se le ha asignado una anotación debe hacerse antes de filtrar pera evitar un error, que se producirá en el caso que intentemos filtrar con el parámetro require.entrezpuesto en TRUE.

El procedimiento de lectura identifica el tipo de array y rellena automáticamente el campo annotation. Podemos visualizarlo con la instrucción annotation.

```{r, message=FALSE, echo=TRUE}
GSE8879_esetrma <- rma(rawData)
show(annotation(GSE8879_esetrma))

```


Aquí hay que proceder con cuidado En arrays de tipo 3’ITV esta información sería la que utilizaríamos, pero el paquete oligoutiliza dos paquetes de anotaciones:

-Los paquetes pd.XXX
-Los paquetes XXXtranscriptcluster.db

Para la anotación necesitamos el segundo, por lo que debemos modificar el contenido del campo “annotation”


```{r, message=FALSE, echo=TRUE}
require(hgu133a.db)
annotation(GSE8879_esetrma) <- "hgu133a.db"
```

Aplicaremos un filtraje “estándar” que retenga el 50% de los genes con mayor variabilidad de entre aquellos que estan correctamente anotados, es decir eliminando aquellos que no tienen identificador en la base de datos Entrez.



```{r, message=FALSE, echo=TRUE}
library(genefilter)
GSE8879_Filtered <- nsFilter(GSE8879_esetrma,
                              require.entrez =
                                TRUE,
                     remove.dupEntrez = TRUE,
                     var.func = IQR,
                     var.cutoff = 0.5, var.filter = TRUE,
                     filterByQuantile = TRUE,
                     feature.exclude = "^AFFX")
```

El resultado del filtraje es una lista con varios objetos, que informan de lo que se ha descartado y un objeto expressionSet que, en lugar de 29129 “features” tiene 10039 que son los que estan anotados y tienen mayor variabilidad. La selección de genes se llevará a cabo sobre esta lista.



```{r, message=FALSE, echo=TRUE}
names(GSE8879_Filtered)
class(GSE8879_Filtered$eset)
print(GSE8879_Filtered$filter.log)
```

```{r, message=FALSE, echo=TRUE}
eset_GSE8879_Filtered <- GSE8879_Filtered$eset
eset_GSE8879_Filtered
```

## Anotación


Pasamos a la *anotación* de los resultados.

Los datos de expresión normalizados se identifican por el nombre de la muestra, que además identifica el grupo, y por el identificador del gen.

Para convertir los identificadores de la compañía Affymetrix en identificadores estándar usaremos el paquete de anotaciones hgu133plus2.db.

Primero hacemos una anotación general.

```{r, message=FALSE, echo=TRUE}
probeIds <- rownames(GSE8879_esetrma)
columns(hgu133a.db)
```

```{r, message=FALSE, echo=TRUE}
GSE8879_geneIds <- AnnotationDbi::select(hgu133a.db,
                                         keys = probeIds,
                                         columns =
                                           c("ENTREZID",
                                             "SYMBOL",
                                             "UNIPROT",
                                             'GO'))
```

```{r, message=FALSE, echo=TRUE}
table(is.na(GSE8879_geneIds))
```

Como hay datos NA, vamos a intentar anotar con otra base de datos.

```{r, message=FALSE, echo=TRUE}
library(readxl)
BD1 <- read_excel("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/Datasets Transcriptome-wide discovery of coding and noncoding RNA-binding proteins/pnas.1718406115.sd01.xlsx")
colnames(BD1)<-BD1[1,]
BD1<-BD1[4:1274,]
BD1<-as.data.frame(BD1)
BD1<-BD1[,c(-2,-3, -rep(6:44))]
```



```{r, message=FALSE, echo=TRUE}
head(BD1)
```

La primera columna hace referencia al UNIPROT de la base de geneIds. Luego, la columna Gene hace referencia al SYMBOL. Vamos a intentar rellenar la información que nos falta.

```{r, message=FALSE, echo=TRUE}
strtrim((sort(GSE8879_geneIds[,4]))[1], 3)
head(which(is.na(GSE8879_geneIds[,2])))
head(which(is.na(GSE8879_geneIds[,3])))
head(which(is.na(GSE8879_geneIds[,4])))
head(which(is.na(BD1[,2])))
```


Hay más NA en la 4 fila, entonces, utilizaremos la 3.

```{r, message=FALSE, echo=TRUE}
GSE8879_geneIds$Protein_Name<-NA
```

```{r, message=FALSE, echo=TRUE, error=TRUE}
n_fil=nrow(GSE8879_geneIds)
n_col=ncol(GSE8879_geneIds)
n_filBD1=nrow(BD1)
n_colBD1=ncol(BD1)

for (i_row in 1:n_fil){
  
  # TERCERA FILA
  for (i in 1:n_filBD1){ # para las filas de BD1, 
    if (GSE8879_geneIds[i_row,3]==BD1[i,3] & !(is.na(GSE8879_geneIds[i_row,3]==BD1[i,3]))){ # buscar el valor de 3 de GSE_geneIds igual a la 3/Gene en BD1
      GSE8879_geneIds[i_row,5]<-BD1[i,2] }}  # cambiar el valor NA de la 4 de GSE_geneIds por el de la 1 col de BD1
    
  }
  
  
```


```{r, message=FALSE, echo=TRUE}
(which(!is.na(GSE8879_geneIds[8341:44004,5])))
  
```

Se ha anotado hasta la fila 8341.


```{r, message=FALSE, echo=TRUE}
# a<-GSE8879_geneIds[8341:44004,]

# n_fil=nrow(a)
# n_col=ncol(a)
# n_filBD1=nrow(BD1)
# n_colBD1=ncol(BD1)

# for (i_row in 1:n_fil){
  
  # TERCERA FILA
  # for (i in 1:n_filBD1){ # para las filas de BD1, 
    # if (a[i_row,3]==BD1[i,3] & !(is.na(a[i_row,3]==BD1[i,3]))){ # buscar el valor de 3 de GSE_geneIds igual a la 3/Gene en BD1
     #  a[i_row,5]<-BD1[i,2] }}  # cambiar el valor NA de la 4 de GSE_geneIds por el de la 1 col de BD1
    
  # }
```



```{r, message=FALSE, echo=TRUE}
# GSE8879_geneIds[8341:44004,]<-a
# b<-GSE8879_geneIds[27480:44004,]
# y el mismo bucle que a.
# GSE8879_geneIds[27480:44004,]<-b
```


```{r, message=FALSE, echo=TRUE}
library("writexl")
write_xlsx(GSE8879_geneIds,"C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE8879/GSE8879_geneIds.xlsx")
```

## Archivos de resultados normalizados

Los dos objetos expressionSet resultantes de la normalización y el filtraje se almacenan en un archivo binario datos.normalizados.Rda, que será la base para todos los estudios posteriores.

Guardamos el archivo de datos normalizado.

```{r, message=FALSE, echo=TRUE}
save(GSE8879_Filtered, eset_GSE8879_Filtered,
     GSE8879_geneIds, file =
       "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE8879/datos.normalizados.Rda")
```


# GSE10609


## Normalización

```{r, message=FALSE, echo=TRUE}
GSE10609_esetrma <- rma(GSE10609_rawData)
show(annotation(GSE10609_esetrma))
```

## Filtraje

Seguimos con otro filtrado. Filtraje no específico. 

```{r, message=FALSE, echo=TRUE}

show(annotation(GSE10609_esetrma))
```


```{r, message=FALSE, echo=TRUE}
require(hgu133plus2.db)
annotation(GSE10609_esetrma) <- "hgu133plus2.db"
```

Aplicaremos un filtraje “estándar” que retenga el 50% de los genes con mayor variabilidad de entre aquellos que estan correctamente anotados, es decir eliminando aquellos que no tienen identificador en la base de datos Entrez.



```{r, message=FALSE, echo=TRUE}
library(genefilter)
GSE10609_Filtered <- nsFilter(GSE10609_esetrma,
                              require.entrez =
                                TRUE,
                     remove.dupEntrez = TRUE,
                     var.func = IQR,
                     var.cutoff = 0.5, var.filter = TRUE,
                     filterByQuantile = TRUE,
                     feature.exclude = "^AFFX")
```

El resultado del filtraje es una lista con varios objetos, que informan de lo que se ha descartado y un objeto expressionSet que, en lugar de 29129 “features” tiene 10039 que son los que estan anotados y tienen mayor variabilidad. La selección de genes se llevará a cabo sobre esta lista.



```{r, message=FALSE, echo=TRUE}
names(GSE10609_Filtered)
class(GSE10609_Filtered$eset)
print(GSE10609_Filtered$filter.log)
```

```{r, message=FALSE, echo=TRUE}
eset_GSE10609_Filtered <- GSE10609_Filtered$eset
eset_GSE10609_Filtered
```

## Anotación


Pasamos a la *anotación* de los resultados.

Los datos de expresión normalizados se identifican por el nombre de la muestra, que además identifica el grupo, y por el identificador del gen.

Para convertir los identificadores de la compañía Affymetrix en identificadores estándar usaremos el paquete de anotaciones hgu133plus2.db.

Primero hacemos una anotación general.

```{r, message=FALSE, echo=TRUE}

GSE10609_eset.e<-exprs(eset_GSE10609_Filtered) ## archivo de matriz obtenido. No como lo hizo el profe...
# el profe lo hizo con el eset rma

probeIds <- rownames(GSE10609_eset.e)
columns(hgu133plus2.db)
```

```{r, message=FALSE, echo=TRUE}
GSE10609_geneIds <- AnnotationDbi::select(hgu133plus2.db,
                                         keys = probeIds,
                                         columns =
                                           c("ENTREZID",
                                             "SYMBOL",
                                             "UNIPROT",
                                             'GO'))
```

```{r, message=FALSE, echo=TRUE}
table(is.na(GSE10609_geneIds))
```

Hay datos NA, pero los trataremos después, cuando ya haramos seleccionado los genes diferencialmente expresados. Entonces, anotaremos la función de las proteínas.


## Archivos de resultados normalizados

Los dos objetos expressionSet resultantes de la normalización y el filtraje se almacenan en un archivo binario datos.normalizados.Rda, que será la base para todos los estudios posteriores.


```{r, message=FALSE, echo=TRUE}
save(GSE10609_Filtered, eset_GSE10609_Filtered,
     GSE10609_geneIds, file =
       "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE10609/datos.normalizados.Rda")
```


```{r, message=FALSE, echo=TRUE}
library("writexl")
write_xlsx(GSE10609_geneIds,"C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE10609/GSE10609_geneIds.xlsx")
```



# GSE14618_GPL570

No hay ni filtraje ni normalización hecha por nosotros, pero si hicieron normalización en el estudio. Seguimos.



## Normalización

```{r, message=FALSE, echo=TRUE}
library(oligo)
GSE14618_GPL570_esetrma <- oligo::rma(GSE14618_GPL570_rawData)
show(annotation(GSE14618_GPL570_esetrma))
```


## Filtraje

Si nos descargamos la anotación de GPL570, buscando simplemente este nombre en internet, obtenemos un archivo comprimido. Lo descomprimimos y vemos dentro del archivo resultante lo siguiente: !Annotation_platform_title = [HG-U133_Plus_2] Affymetrix Human Genome U133 Plus 2.0 Array

```{r, message=FALSE, echo=TRUE}
setwd('C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE14618/')
require(hgu133plus2.db)
annotation(GSE14618_GPL570_esetrma) <- "hgu133plus2.db"
```

Aplicaremos un filtraje “estándar” que retenga el 50% de los genes con mayor variabilidad de entre aquellos que estan correctamente anotados, es decir eliminando aquellos que no tienen identificador en la base de datos Entrez.



```{r, message=FALSE, echo=TRUE}
library(genefilter)
GSE14618_GPL570_Filtered <- nsFilter(GSE14618_GPL570_esetrma,
                              require.entrez =
                                TRUE,
                     remove.dupEntrez = TRUE,
                     var.func = IQR,
                     var.cutoff = 0.5, var.filter = TRUE,
                     filterByQuantile = TRUE,
                     feature.exclude = "^AFFX")


GSE14618_GPL570<-GSE14618_GPL570_Filtered
```

El resultado del filtraje es una lista con varios objetos, que informan de lo que se ha descartado y un objeto expressionSet que, en lugar de 29129 “features” tiene 10039 que son los que estan anotados y tienen mayor variabilidad. La selección de genes se llevará a cabo sobre esta lista.



```{r, message=FALSE, echo=TRUE}
names(GSE14618_GPL570)
class(GSE14618_GPL570$eset)
print(GSE14618_GPL570$filter.log)
```

```{r, message=FALSE, echo=TRUE}
eset_GSE14618_GPL570_Filtered <- GSE14618_GPL570$eset
eset_GSE14618_GPL570_Filtered
```

## Anotación


Pasamos a la *anotación* de los resultados.

Los datos de expresión normalizados se identifican por el nombre de la muestra, que además identifica el grupo, y por el identificador del gen.

Para convertir los identificadores de la compañía Affymetrix en identificadores estándar usaremos el paquete de anotaciones hgu133plus2.db.

Primero hacemos una anotación general.

```{r, message=FALSE, echo=TRUE}

GSE14618_GPL570_eset.e<-exprs(eset_GSE14618_GPL570_Filtered) ## archivo de matriz obtenido

probeIds <- rownames(GSE14618_GPL570_eset.e)
columns(hgu133plus2.db)
```

```{r, message=FALSE, echo=TRUE}
GSE14618_GPL570__geneIds <- AnnotationDbi::select(hgu133plus2.db,
                                         keys = probeIds,
                                         columns =
                                           c("ENTREZID",
                                             "SYMBOL",
                                             "UNIPROT",
                                             'GO'))
```

```{r, message=FALSE, echo=TRUE}
table(is.na(GSE14618_GPL570__geneIds))
```

Como hay datos NA, anotaremos los resultados después de la selección de los genes.


```{r, message=FALSE, echo=TRUE}
library("writexl")
write_xlsx(GSE14618_GPL570__geneIds,"C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE14618/GPL570_geneIds.xlsx")
```


## Archivos de resultados normalizados

Los dos objetos expressionSet resultantes de la normalización y el filtraje se almacenan en un archivo binario datos.normalizados.Rda, que será la base para todos los estudios posteriores.

Guardamos el archivo de datos normalizado.

```{r, message=FALSE, echo=TRUE}
save(GSE14618_GPL570_Filtered, eset_GSE14618_GPL570_Filtered,
     GSE14618_GPL570__geneIds, file =
       "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE14618/GSE14618_GPL570datos.normalizados.Rda")
```


# GSE14618_GPL96

No hay ni filtraje ni normalización hecha por nosotros, pero si hicieron normalización en el estudio. Seguimos.

## Normalización

```{r, message=FALSE, echo=TRUE}
library(oligo)
GSE14618_GPL96_esetrma <- oligo::rma(GSE14618_GPL96_rawData)
show(annotation(GSE14618_GPL96_esetrma))
```


## Filtraje

Si nos descargamos la anotación de GPL96, buscando simplemente este nombre en internet, obtenemos un archivo comprimido. Lo descomprimimos y vemos dentro del archivo resultante lo siguiente: !Annotation_platform_title = [HG-U133A] Affymetrix Human Genome U133A Array

```{r, message=FALSE, echo=TRUE}
setwd('C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE14618/')
require(hgu133a.db)
annotation(GSE14618_GPL96) <- "hgu133a.db"
```

Aplicaremos un filtraje “estándar” que retenga el 50% de los genes con mayor variabilidad de entre aquellos que estan correctamente anotados, es decir eliminando aquellos que no tienen identificador en la base de datos Entrez.



```{r, message=FALSE, echo=TRUE}
library(genefilter)
GSE14618_GPL96_Filtered <- nsFilter(GSE14618_GPL96,
                              require.entrez =
                                TRUE,
                     remove.dupEntrez = TRUE,
                     var.func = IQR,
                     var.cutoff = 0.5, var.filter = TRUE,
                     filterByQuantile = TRUE,
                     feature.exclude = "^AFFX")

GSE14618_GPL96<-GSE14618_GPL96_Filtered
```

El resultado del filtraje es una lista con varios objetos, que informan de lo que se ha descartado y un objeto expressionSet que, en lugar de 29129 “features” tiene 10039 que son los que estan anotados y tienen mayor variabilidad. La selección de genes se llevará a cabo sobre esta lista.



```{r, message=FALSE, echo=TRUE}
names(GSE14618_GPL96)
class(GSE14618_GPL96$eset)
print(GSE14618_GPL96$filter.log)
```

```{r, message=FALSE, echo=TRUE}
eset_GSE14618_GPL96_Filtered <- GSE14618_GPL96$eset
eset_GSE14618_GPL96_Filtered
```

## Anotación


Pasamos a la *anotación* de los resultados.

Los datos de expresión normalizados se identifican por el nombre de la muestra, que además identifica el grupo, y por el identificador del gen.

Para convertir los identificadores de la compañía Affymetrix en identificadores estándar usaremos el paquete de anotaciones hgu133a.db

Primero hacemos una anotación general.

```{r, message=FALSE, echo=TRUE}

GSE14618_GPL96_eset.e<-exprs(eset_GSE14618_GPL96_Filtered) ## archivo de matriz obtenido

probeIds <- rownames(GSE14618_GPL96_eset.e)
columns(hgu133a.db)
```

```{r, message=FALSE, echo=TRUE}
GSE14618_GPL96__geneIds <- AnnotationDbi::select(hgu133a.db,
                                         keys = probeIds,
                                         columns =
                                           c("ENTREZID",
                                             "SYMBOL",
                                             "UNIPROT",
                                             'GO'))
```

```{r, message=FALSE, echo=TRUE}
table(is.na(GSE14618_GPL96__geneIds))
```

Como hay datos NA, anotaremos los resultados después de la selección de los genes.


```{r, message=FALSE, echo=TRUE}
library("writexl")
write_xlsx(GSE14618_GPL96__geneIds,"C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE14618/GSE14618_GPL96_geneIds.xlsx")
```


## Archivos de resultados normalizados

Los dos objetos expressionSet resultantes de la normalización y el filtraje se almacenan en un archivo binario datos.normalizados.Rda, que será la base para todos los estudios posteriores.

Guardamos el archivo de datos normalizado.

```{r, message=FALSE, echo=TRUE}
save(GSE14618_GPL96_Filtered, eset_GSE14618_GPL96_Filtered,
     GSE14618_GPL96__geneIds, file =
       "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE14618/GSE14618_GPL96datos.normalizados.Rda")
```


# GSE26713

## Filtraje


```{r, message=FALSE, echo=TRUE}

show(annotation(GSE26713_Filtered))
```



```{r, message=FALSE, echo=TRUE}
require(hgu133plus2.db)
annotation(GSE26713_Filtered) <- "hgu133plus2.db"
```

```{r, message=FALSE, echo=TRUE}
library(genefilter)
GSE26713_Filtered <- nsFilter(GSE26713_Filtered,
                              require.entrez =
                                TRUE,
                     remove.dupEntrez = TRUE,
                     var.func = IQR,
                     var.cutoff = 0.5, var.filter = TRUE,
                     filterByQuantile = TRUE,
                     feature.exclude = "^AFFX")
```

El resultado del filtraje es una lista con varios objetos, que informan de lo que se ha descartado y un objeto expressionSet que, en lugar de 29129 “features” tiene 10039 que son los que estan anotados y tienen mayor variabilidad. La selección de genes se llevará a cabo sobre esta lista.



```{r, message=FALSE, echo=TRUE}
names(GSE26713_Filtered)
class(GSE26713_Filtered$eset)
print(GSE26713_Filtered$filter.log)
```

```{r, message=FALSE, echo=TRUE}
eset_GSE26713_Filtered <- GSE26713_Filtered$eset
eset_GSE26713_Filtered
```

## Anotación

```{r, message=FALSE, echo=TRUE}

GSE26713_eset.e<-exprs(eset_GSE26713_Filtered) ## archivo de matriz obtenido

probeIds <- rownames(GSE26713_eset.e)

```

```{r, message=FALSE, echo=TRUE}
GSE26713_geneIds <- AnnotationDbi::select(hgu133plus2.db,
                                         keys = probeIds,
                                         columns =
                                           c("ENTREZID",
                                             "SYMBOL",
                                             "UNIPROT",
                                             'GO'))
```

```{r, message=FALSE, echo=TRUE}
table(is.na(GSE26713_geneIds))
```

Como hay datos NA, vamos a anotar posteriormente.

```{r, message=FALSE, echo=TRUE}
library("writexl")
write_xlsx(GSE26713_geneIds,"C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE26713/GSE26713_geneIds.xlsx")
```

## Archivos de resultados normalizados

Los dos objetos expressionSet resultantes de la normalización y el filtraje se almacenan en un archivo binario datos.normalizados.Rda, que será la base para todos los estudios posteriores.

Guardamos el archivo de datos normalizado.

```{r, message=FALSE, echo=TRUE}
save(GSE26713_Filtered, eset_GSE26713_Filtered,
     GSE26713_geneIds, file =
       "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE26713/datos.normalizados.Rda")
```

```{r, message=FALSE, echo=TRUE}
sampleInfo <- AnnotatedDataFrame(GSE26713_selectedTargets)

library(oligo)

CELfiles <- GSE26713_selectedTargets$fileNames

setwd('C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE26713/')

GSE26713_rawData <- read.celfiles(paste0(GSE26713_selectedTargets$fileNames, '.CEL'))

colnames(exprs(GSE26713_rawData)) <- rownames(pData(GSE26713_rawData))

GSE26713_grupos <- as.factor(pData(GSE26713_rawData)$grupo)
```



# GSE28703

## Filtraje

Hicimos:

GSE28703_eset<-affy::rma(GSE28703_affy,verbose=FALSE)

GSE28703_eset.e<-exprs(GSE28703_eset)

```{r, message=FALSE, echo=TRUE}

show(annotation(GSE28703_eset))
```

Haremos un filtradop, y no dos como con el resto, ya que no pudimos hacer el anterior.

```{r, message=FALSE, echo=TRUE}
require(hthgu133pluspm.db)
annotation(GSE28703_eset) <- "hthgu133pluspm.db"
```

Aplicaremos un filtraje “estándar” que retenga el 50% de los genes con mayor variabilidad de entre aquellos que estan correctamente anotados, es decir eliminando aquellos que no tienen identificador en la base de datos Entrez.



```{r, message=FALSE, echo=TRUE}
library(genefilter)
GSE28703_Filtered <- nsFilter(GSE28703_eset,
                              require.entrez =
                                TRUE,
                     remove.dupEntrez = TRUE,
                     var.func = IQR,
                     var.cutoff = 0.5, var.filter = TRUE,
                     filterByQuantile = TRUE,
                     feature.exclude = "^AFFX")
```

El resultado del filtraje es una lista con varios objetos, que informan de lo que se ha descartado y un objeto expressionSet que, en lugar de 29129 “features” tiene 10039 que son los que estan anotados y tienen mayor variabilidad. La selección de genes se llevará a cabo sobre esta lista.



```{r, message=FALSE, echo=TRUE}
names(GSE28703_Filtered)
class(GSE28703_Filtered$eset)
print(GSE28703_Filtered$filter.log)
```

```{r, message=FALSE, echo=TRUE}
eset_GSE28703_Filtered <- GSE28703_Filtered$eset
eset_GSE28703_Filtered
```

## Anotación

Para convertir los identificadores de la compañía Affymetrix en identificadores estándar usaremos el paquete de anotaciones hgu133plus2.db.

Primero hacemos una anotación general.

```{r, message=FALSE, echo=TRUE}

GSE28703_eset.e<-exprs(eset_GSE28703_Filtered) ## archivo de matriz obtenido

probeIds <- rownames(GSE28703_eset.e)
columns(hthgu133pluspm.db)
```

```{r, message=FALSE, echo=TRUE}
GSE28703_geneIds <- AnnotationDbi::select(hthgu133pluspm.db,
                                         keys = probeIds,
                                         columns =
                                           c("ENTREZID",
                                             "SYMBOL",
                                             "UNIPROT",
                                             'GO'))
```

```{r, message=FALSE, echo=TRUE}
table(is.na(GSE28703_geneIds))
```

Como hay datos NA, anotaremos posteriormente. Ahora guardamos los nombres:

```{r, message=FALSE, echo=TRUE}
library("writexl")
write_xlsx(GSE28703_geneIds,"C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE28703/GSE28703_geneIds.xlsx")
```

## Archivos de resultados normalizados

Guardamos el archivo de datos normalizado.

```{r, message=FALSE, echo=TRUE}
save(GSE28703_Filtered, eset_GSE28703_Filtered,
     GSE28703_geneIds, file =
       "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE28703/datos.normalizados.Rda")
```

```{r, message=FALSE, echo=TRUE}
sampleInfo <- AnnotatedDataFrame(GSE28703_selectedTargets)

library(oligo)

CELfiles <- GSE28703_selectedTargets$fileNames

dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE28703/"

GSE28703_rawData <- read.celfiles(file.path(dir, CELfiles), phenoData = sampleInfo)

colnames(exprs(GSE28703_rawData)) <- rownames(pData(GSE28703_rawData))

GSE28703_grupos <- as.factor(pData(GSE28703_rawData)$grupo)
```



# GSE32215


## Filtraje


```{r, message=FALSE, echo=TRUE}

show(annotation(GSE32215_Filtered))
```



```{r, message=FALSE, echo=TRUE}
require(hgu133plus2.db)
annotation(GSE32215_Filtered) <- "hgu133plus2.db"
```



```{r, message=FALSE, echo=TRUE}
library(genefilter)
GSE32215_Filtered <- nsFilter(GSE32215_Filtered,
                              require.entrez =
                                TRUE,
                     remove.dupEntrez = TRUE,
                     var.func = IQR,
                     var.cutoff = 0.5, var.filter = TRUE,
                     filterByQuantile = TRUE,
                     feature.exclude = "^AFFX")
```



```{r, message=FALSE, echo=TRUE}
names(GSE32215_Filtered)
class(GSE32215_Filtered$eset)
print(GSE32215_Filtered$filter.log)
```

```{r, message=FALSE, echo=TRUE}
eset_GSE32215_Filtered <- GSE32215_Filtered$eset
eset_GSE32215_Filtered
```

## Anotación


Pasamos a la *anotación* de los resultados.

Los datos de expresión normalizados se identifican por el nombre de la muestra, que además identifica el grupo, y por el identificador del gen.

Para convertir los identificadores de la compañía Affymetrix en identificadores estándar usaremos el paquete de anotaciones hgu133plus2.db.

Primero hacemos una anotación general.

```{r, message=FALSE, echo=TRUE}

GSE32215_eset.e<-exprs(eset_GSE32215_Filtered) ## archivo de matriz obtenido

probeIds <- rownames(GSE32215_eset.e)
columns(hgu133plus2.db)
```

```{r, message=FALSE, echo=TRUE}
GSE32215_geneIds <- AnnotationDbi::select(hgu133plus2.db,
                                         keys = probeIds,
                                         columns =
                                           c("ENTREZID",
                                             "SYMBOL",
                                             "UNIPROT",
                                             'GO'))
```

BP, MF y CC representan los grupos de procesos biológicos, funciones moleculares y componentes celulares de GO.


```{r, message=FALSE, echo=TRUE}
table(is.na(GSE32215_geneIds))
```

Como hay datos NA, vamos a intentar hacer cosas más tarde.

```{r, message=FALSE, echo=TRUE}
library("writexl")
write_xlsx(GSE32215_geneIds,"C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE32215/GSE32215_geneIds.xlsx")
```

## Archivos de resultados normalizados

```{r, message=FALSE, echo=TRUE}
save(GSE32215_Filtered, eset_GSE32215_Filtered,
     GSE32215_geneIds, file =
       "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE32215/datos.normalizados.Rda")
```

```{r, message=FALSE, echo=TRUE}
sampleInfo <- AnnotatedDataFrame(GSE32215_selectedTargets)

library(oligo)

CELfiles <- GSE32215_selectedTargets$fileNames

dir="C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE32215/"

GSE32215_rawData <- read.celfiles(file.path(dir, paste0(GSE32215_selectedTargets$fileNames, '.CEL')), phenoData = sampleInfo)

colnames(exprs(GSE32215_rawData)) <- rownames(pData(GSE32215_rawData))

GSE32215_grupos <- as.factor(pData(GSE32215_rawData)$grupo)
```






# GSE33469


## Filtraje

Hicimos:

GSE33469_getGEO@phenoData<-sampleInfo
GSE33469_rawData<-GSE33469_getGEO
colnames(exprs(GSE33469_rawData)) <- rownames(pData(GSE33469_rawData))

En vez de: GSE33469_rawData <- read.celfiles(file.path("C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE33469", CELfiles), phenoData = sampleInfo). No había archivos.CEL.

No vamos a normalizarlo. En internet te puedes desacargar GSE33469_RAW.tar o GSE33469_non-normalized.txt.gz, por lo que pensamos que está normalizado. Además, el boxplot y el histograma indican que lo están. No haremos:

GSE33469_eset <- affy::rma(GSE33469_rawData)

```{r, message=FALSE, echo=TRUE}
GSE33469_eset <- GSE33469_rawData
show(annotation(GSE33469_eset))
```

Si nos descargamos y descomprimimos GPL10558.annot, nos sale en su txt lo siguiente:

^Annotation

!Annotation_date = Aug 09 2016

!Annotation_platform = GPL10558

!Annotation_platform_title = Illumina HumanHT-12 V4.0 expression beadchip

Buscando en internet:

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("illuminaHumanv4.db")


Haremos un filtradop, y no dos como con el resto, ya que no pudimos hacer el anterior.

```{r, message=FALSE, echo=TRUE}


require(illuminaHumanv4.db)
annotation(GSE33469_eset) <- "illuminaHumanv4.db"
```


```{r, message=FALSE, echo=TRUE}
library(genefilter)
GSE33469_Filtered <- nsFilter(GSE33469_eset,
                              require.entrez =
                                TRUE,
                     remove.dupEntrez = TRUE,
                     var.func = IQR,
                     var.cutoff = 0.5, var.filter = TRUE,
                     filterByQuantile = TRUE,
                     feature.exclude = "^AFFX")
```

El resultado del filtraje es una lista con varios objetos, que informan de lo que se ha descartado y un objeto expressionSet que, en lugar de 29129 “features” tiene 10039 que son los que estan anotados y tienen mayor variabilidad. La selección de genes se llevará a cabo sobre esta lista.



```{r, message=FALSE, echo=TRUE}
names(GSE33469_Filtered)
class(GSE33469_Filtered$eset)
print(GSE33469_Filtered$filter.log)
```

```{r, message=FALSE, echo=TRUE}
eset_GSE33469_Filtered <- GSE33469_Filtered$eset
eset_GSE33469_Filtered
```

## Anotación

Para convertir los identificadores de la compañía Affymetrix en identificadores estándar usaremos el paquete de anotaciones hgu133plus2.db.

Primero hacemos una anotación general.

```{r, message=FALSE, echo=TRUE}

GSE33469_eset.e<-exprs(eset_GSE33469_Filtered) ## archivo de matriz obtenido

probeIds <- rownames(GSE33469_eset.e)
columns(illuminaHumanv4.db)
```

```{r, message=FALSE, echo=TRUE}
GSE33469_geneIds <- AnnotationDbi::select(illuminaHumanv4.db,
                                         keys = probeIds,
                                         columns =
                                           c("ENTREZID",
                                             "SYMBOL",
                                             "UNIPROT",
                                             'GO'))
```

```{r, message=FALSE, echo=TRUE}
table(is.na(GSE33469_geneIds))
```

Como hay datos NA, anotaremos posteriormente. Ahora guardamos los nombres:

```{r, message=FALSE, echo=TRUE}
library("writexl")
write_xlsx(GSE33469_geneIds,"C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE33469/GSE33469_geneIds.xlsx")
```

## Archivos de resultados normalizados

Guardamos el archivo de datos normalizado.

```{r, message=FALSE, echo=TRUE}
save(GSE33469_Filtered, eset_GSE33469_Filtered,
     GSE33469_geneIds, file =
       "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE33469/datos.normalizados.Rda")
```






# GSE33470

Hicimos:

GSE33470_rawData <- GSE33470_getGEO

GSE33470_rawData@phenoData <- sampleInfo

colnames(exprs(GSE33470_rawData)) <- rownames(pData(GSE33470_rawData))

No vamos a normalizarlo. En internet te puedes desacargar GSE33469_RAW.tar o GSE33469_non-normalized.txt.gz, por lo que pensamos que está normalizado. Además, el boxplot y el histograma indican que lo están. No haremos:

GSE33470_eset <- affy::rma(GSE33470_rawData)

```{r, message=FALSE, echo=TRUE}
GSE33470_eset <- GSE33470_rawData
show(annotation(GSE33470_eset))
```

Si poneos GPL10558 en internet nos sale:

Each array on the HumanHT-12 v4 Expression BeadChip targets more than 31,000 annotated genes


Haremos un filtradop, y no dos como con el resto, ya que no pudimos hacer el anterior.

```{r, message=FALSE, echo=TRUE}
require(illuminaHumanv4.db)
annotation(GSE33470_eset) <- "illuminaHumanv4.db"
```


```{r, message=FALSE, echo=TRUE}
library(genefilter)
GSE33470_Filtered <- nsFilter(GSE33470_eset,
                              require.entrez =
                                TRUE,
                     remove.dupEntrez = TRUE,
                     var.func = IQR,
                     var.cutoff = 0.5, var.filter = TRUE,
                     filterByQuantile = TRUE,
                     feature.exclude = "^AFFX")
```

El resultado del filtraje es una lista con varios objetos, que informan de lo que se ha descartado y un objeto expressionSet que, en lugar de 29129 “features” tiene 10039 que son los que estan anotados y tienen mayor variabilidad. La selección de genes se llevará a cabo sobre esta lista.



```{r, message=FALSE, echo=TRUE}
names(GSE33470_Filtered)
class(GSE33470_Filtered$eset)
print(GSE33470_Filtered$filter.log)
```

```{r, message=FALSE, echo=TRUE}
eset_GSE33470_Filtered <- GSE33470_Filtered$eset
eset_GSE33470_Filtered
```

## Anotación

Para convertir los identificadores de la compañía Affymetrix en identificadores estándar usaremos el paquete de anotaciones hgu133plus2.db.

Primero hacemos una anotación general.

```{r, message=FALSE, echo=TRUE}

GSE33470_eset.e<-exprs(eset_GSE33470_Filtered) ## archivo de matriz obtenido

probeIds <- rownames(GSE33470_eset.e)
```

```{r, message=FALSE, echo=TRUE}
GSE33470_geneIds <- AnnotationDbi::select(illuminaHumanv4.db,
                                         keys = probeIds,
                                         columns =
                                           c("ENTREZID",
                                             "SYMBOL",
                                             "UNIPROT",
                                             'GO'))
```

```{r, message=FALSE, echo=TRUE}
table(is.na(GSE33470_geneIds))
```

Como hay datos NA, anotaremos posteriormente. Ahora guardamos los nombres:

```{r, message=FALSE, echo=TRUE}
library("writexl")
write_xlsx(GSE33470_geneIds,"C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE33470/GSE33470_geneIds.xlsx")
```

## Archivos de resultados normalizados

Guardamos el archivo de datos normalizado.

```{r, message=FALSE, echo=TRUE}
save(GSE33470_Filtered, eset_GSE33470_Filtered,
     GSE33470_geneIds, file =
       "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE33470/datos.normalizados.Rda")
```






# GSE37389

Este conjunto necesita normalización, según lo que indicaba el boxplot...pero los valores están po debajo de 16, por lo que no realizamos una transfromación logarítmica. Sin embargo, cuando abrimos GSE37389_series_matrix.txt vemos:


!Sample_data_processing	"The normalization was done using GeneSpring GX 7.3 Software. Recommended Percentile Shift Normalization and median of all samples. Significant genes high and low expressed among the groups was identified.". Así que no nos preocuparemos.



## Filtraje

Seguimos con otro filtrado. El filtraje no específico permite eliminar los genes que varían poco entre condiciones o que deseamos quitar por otras razones como por ejemplo que no disponemos de anotación para ellos. La función nsFilter permite eliminar los genes que, o bien varían poco, o bien no se dispone de anotación para ellos. Si al filtrar deseamos usar las anotaciones, o la falta de ellas, como criterio de filtraje debemos disponer del correspondiente paquete de anotaciones.

Si al crear el objeto expressionSet no se le ha asignado una anotación debe hacerse antes de filtrar pera evitar un error, que se producirá en el caso que intentemos filtrar con el parámetro require.entrezpuesto en TRUE.

El procedimiento de lectura identifica el tipo de array y rellena automáticamente el campo annotation. Podemos visualizarlo con la instrucción annotation.

```{r, message=FALSE, echo=TRUE}

show(annotation(GSE37389_rawData))
```

Nos descargamos GLP6480.annot, y dentro:

!Annotation_platform_title = Agilent-014850 Whole Human Genome Microarray 4x44K G4112F (Probe Name version).

Si buscamos '4x44K G4112F Probe db', en internet pone que se puede usar hgug4112a.db.



```{r, message=FALSE, echo=TRUE}
require(hgug4112a.db)
annotation(GSE37389_rawData) <- "hgug4112a.db"
```

Aplicaremos un filtraje “estándar” que retenga el 50% de los genes con mayor variabilidad de entre aquellos que estan correctamente anotados, es decir eliminando aquellos que no tienen identificador en la base de datos Entrez.



```{r, message=FALSE, echo=TRUE}
library(genefilter)
GSE37389_Filtered <- nsFilter(GSE37389_rawData,
                              require.entrez =
                                TRUE,
                     remove.dupEntrez = TRUE,
                     var.func = IQR,
                     var.cutoff = 0.5, var.filter = TRUE,
                     filterByQuantile = TRUE,
                     feature.exclude = "^AFFX")
```



```{r, message=FALSE, echo=TRUE}
names(GSE37389_Filtered)
class(GSE37389_Filtered$eset)
print(GSE37389_Filtered$filter.log)
```

```{r, message=FALSE, echo=TRUE}
eset_GSE37389_Filtered <- GSE37389_Filtered$eset
eset_GSE37389_Filtered
```

## Anotación


Pasamos a la *anotación* de los resultados.

Los datos de expresión normalizados se identifican por el nombre de la muestra, que además identifica el grupo, y por el identificador del gen.

Para convertir los identificadores de la compañía Affymetrix en identificadores estándar usaremos el paquete de anotaciones hgu133plus2.db.

Primero hacemos una anotación general.

```{r, message=FALSE, echo=TRUE}

GSE37389_eset.e<-exprs(eset_GSE37389_Filtered) ## archivo de matriz obtenido

probeIds <- rownames(GSE37389_eset.e)
columns(hgug4112a.db)
```

```{r, message=FALSE, echo=TRUE}
GSE37389_geneIds <- AnnotationDbi::select(hgug4112a.db,
                                         keys = probeIds,
                                         columns =
                                           c("ENTREZID",
                                             "SYMBOL",
                                             "UNIPROT",
                                             'GO'))
```

```{r, message=FALSE, echo=TRUE}
table(is.na(GSE37389_geneIds))
```

Como hay datos NA, intentaremos cambiarlo posteriormente. 

```{r, message=FALSE, echo=TRUE}
library("writexl")
write_xlsx(GSE37389_geneIds,"C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE37389/GSE37389_geneIds.xlsx")
```

## Archivos de resultados normalizados

Los dos objetos expressionSet resultantes de la normalización y el filtraje se almacenan en un archivo binario datos.normalizados.Rda, que será la base para todos los estudios posteriores.

Guardamos el archivo de datos normalizado.

```{r, message=FALSE, echo=TRUE}
save(GSE37389_Filtered, eset_GSE37389_Filtered,
     GSE37389_geneIds, file =
       "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE37389/datos.normalizados.Rda")
```


# GSE56488


Hicimos ya la normalización: 

GSE56488_affydb<-annPkgName(GSE56488_affy@annotation,type="db")

require(GSE56488_affydb, character.only=TRUE)

GSE56488_eset <-oligo::rma(GSE56488_affyExpressionFS) #en vez de:

GSE56488_eset<-rma(GSE56488_affy,verbose=FALSE)

GSE56488_eset.e<-exprs(GSE56488_eset)

Y luego creamos GSE56488_selectedTargets

## Filtraje

Seguimos con otro filtrado. El filtraje no específico permite eliminar los genes que varían poco entre condiciones o que deseamos quitar por otras razones como por ejemplo que no disponemos de anotación para ellos. La función nsFilter permite eliminar los genes que, o bien varían poco, o bien no se dispone de anotación para ellos. Si al filtrar deseamos usar las anotaciones, o la falta de ellas, como criterio de filtraje debemos disponer del correspondiente paquete de anotaciones.

Si al crear el objeto expressionSet no se le ha asignado una anotación debe hacerse antes de filtrar pera evitar un error, que se producirá en el caso que intentemos filtrar con el parámetro require.entrezpuesto en TRUE.

El procedimiento de lectura identifica el tipo de array y rellena automáticamente el campo annotation. Podemos visualizarlo con la instrucción annotation.

```{r, message=FALSE, echo=TRUE}

show(annotation(GSE56488_eset))
```

Esto no es un paquete para anotar. Vemos en GPL17889.annot:

!Platform_title = [HuGene-2_0-st] Affymetrix Human Gene 2.0 ST Array [HuGene20stv1_Hs_ENTREZG_16.0.0]

Usaremos, segun internet, hugene20sttranscriptcluster.db.

```{r, message=FALSE, echo=TRUE}
require(hugene20sttranscriptcluster.db)
annotation(GSE56488_eset) <- "hugene20sttranscriptcluster.db"
```

Aplicaremos un filtraje “estándar” que retenga el 50% de los genes con mayor variabilidad de entre aquellos que estan correctamente anotados, es decir eliminando aquellos que no tienen identificador en la base de datos Entrez.



```{r, message=FALSE, echo=TRUE}
library(genefilter)
GSE56488_Filtered <- nsFilter(GSE56488_eset,
                              require.entrez =
                                TRUE,
                     remove.dupEntrez = TRUE,
                     var.func = IQR,
                     var.cutoff = 0.5, var.filter = TRUE,
                     filterByQuantile = TRUE,
                     feature.exclude = "^AFFX")
```


```{r, message=FALSE, echo=TRUE}
names(GSE56488_Filtered)
class(GSE56488_Filtered$eset)
print(GSE56488_Filtered$filter.log)
```

```{r, message=FALSE, echo=TRUE}
eset_GSE56488_Filtered <- GSE56488_Filtered$eset
eset_GSE56488_Filtered
```

## Anotación


Pasamos a la *anotación* de los resultados.

Los datos de expresión normalizados se identifican por el nombre de la muestra, que además identifica el grupo, y por el identificador del gen.

Para convertir los identificadores de la compañía Affymetrix en identificadores estándar usaremos el paquete de anotaciones hgu133plus2.db.

Primero hacemos una anotación general.

```{r, message=FALSE, echo=TRUE}

GSE56488_eset.e<-exprs(eset_GSE56488_Filtered) ## archivo de matriz obtenido

probeIds <- rownames(GSE56488_eset.e)
columns(hugene20sttranscriptcluster.db)
```

```{r, message=FALSE, echo=TRUE}
GSE56488_geneIds <- AnnotationDbi::select(hugene20sttranscriptcluster.db,
                                         keys = probeIds,
                                         columns =
                                           c("ENTREZID",
                                             "SYMBOL",
                                             "UNIPROT",
                                             "GO"))
```

```{r, message=FALSE, echo=TRUE}
table(is.na(GSE56488_geneIds))
```

Como hay datos NA, vamos a intentar anotar con otra base de datos posteriromente.


```{r, message=FALSE, echo=TRUE}
library("writexl")
write_xlsx(GSE56488_geneIds,"C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE56488/GSE56488_geneIds.xlsx")
```

## Archivos de resultados normalizados

Los dos objetos expressionSet resultantes de la normalización y el filtraje se almacenan en un archivo binario datos.normalizados.Rda, que será la base para todos los estudios posteriores.

Guardamos el archivo de datos normalizado.

```{r, message=FALSE, echo=TRUE}
save(GSE56488_Filtered, eset_GSE56488_Filtered,
     GSE56488_geneIds, file =
       "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE56488/datos.normalizados.Rda")
```





# GSE62156

## Filtraje

```{r, message=FALSE, echo=TRUE}

show(annotation(GSE62156_Filtered))
```



```{r, message=FALSE, echo=TRUE}
require(hgu133plus2.db)
annotation(GSE62156_Filtered) <- "hgu133plus2.db"
```



```{r, message=FALSE, echo=TRUE}
library(genefilter)
GSE62156_Filtered <- nsFilter(GSE62156_Filtered,
                              require.entrez =
                                TRUE,
                     remove.dupEntrez = TRUE,
                     var.func = IQR,
                     var.cutoff = , var.filter = TRUE,
                     filterByQuantile = TRUE,
                     feature.exclude = "^AFFX")
```


```{r, message=FALSE, echo=TRUE}
names(GSE62156_Filtered)
class(GSE62156_Filtered$eset)
print(GSE62156_Filtered$filter.log)
```

```{r, message=FALSE, echo=TRUE}
eset_GSE62156_Filtered <- GSE62156_Filtered$eset
eset_GSE62156_Filtered
```

## Anotación


Pasamos a la *anotación* de los resultados.

Los datos de expresión normalizados se identifican por el nombre de la muestra, que además identifica el grupo, y por el identificador del gen.

Para convertir los identificadores de la compañía Affymetrix en identificadores estándar usaremos el paquete de anotaciones hgu133plus2.db.

Primero hacemos una anotación general.

```{r, message=FALSE, echo=TRUE}

GSE62156_eset.e<-exprs(eset_GSE62156_Filtered) ## archivo de matriz obtenido

probeIds <- rownames(GSE62156_eset.e)
columns(hgu133plus2.db)
```

```{r, message=FALSE, echo=TRUE}
GSE62156_geneIds <- AnnotationDbi::select(hgu133plus2.db,
                                         keys = probeIds,
                                         columns =
                                           c("ENTREZID",
                                             "SYMBOL",
                                             "UNIPROT",
                                             'GO'))
```

```{r, message=FALSE, echo=TRUE}
table(is.na(GSE62156_geneIds))
```

Como hay datos NA, vamos a intentar anotar con otra base de datos al cabo de unos pasos.


```{r, message=FALSE, echo=TRUE}
library("writexl")
write_xlsx(GSE62156_geneIds,"C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE62156/GSE62156_geneIds.xlsx")
```

## Archivos de resultados normalizados


Guardamos el archivo de datos normalizado.

```{r, message=FALSE, echo=TRUE}
save(GSE62156_Filtered, eset_GSE62156_Filtered,
     GSE62156_geneIds, file =
       "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE62156/datos.normalizados.Rda")
```



# Preprocesado 2. Datos de RNA-seq

# GSE110633


## Normalización

Además de estandarizar los contajes, es importante eliminar otros sesgos de composición entre librerías. Esto puede hacerse aplicando la normalización por el método TMM que genera un conjunto de factores de normalización, tal que producto de estos factores y los tamaños de librería (el número de secuencias de cada muestra) definen el tamaño efectivo de dichas muestras, es decir el peso real que se les asignará en las comparaciones posteriores.

Aunque esto puede parecer artificial, no lo es porque la normalización tiene en cuenta otros factores, como el sesgo de composición entre librerías, que podrían hacer que los mismos valores en distintas muestras no reflejaran su importancia relativa.

La función calcNormFactors, de la librería edgeR, calcula los factores de normalización mencionados.

```{r, message=FALSE, echo=TRUE}
library(edgeR)
GSE110633_dgeObjnorm <- calcNormFactors(GSE110633_dgeObj)
head(GSE110633_dgeObj$samples, 10)
head(GSE110633_dgeObjnorm$samples, 10)
```

Es decir, aunque no se observen cambios en la matriz de contajes, cuando se utilizan estos factores de normalización en algún cálculo la importancia de las distintas columnas se tendrá en cuenta.




## Transformación logarítmica

Las transformaciones anteriores buscan compensar el tamaño distinto de las librerías o la distinta composición de éstas, pero las distribuciones de los contajes en cada muestra son asimétricas.


```{r, message=FALSE, echo=TRUE}
a<-GSE110633_dgeObj


for(i in 1:length(a[["samples"]][["group"]])) {
  a[["samples"]][["samples"]][i]<-paste0(a[["samples"]][["group"]][i], i)
  
  }


b<-GSE110633_dgeObjnorm

b[["samples"]][["samples"]]<-a[["samples"]][["samples"]]

colnames(b$counts)<-b[["samples"]][["samples"]]
```


```{r, message=FALSE, echo=TRUE}
boxplot(b$counts, col = b$samples$cols, las = 2, cex.axis = 0.7,
    main = "Contajes normalizados", ylim = c(0, 10000))
```

Para finalizar el preprocesado se toman logaritmo base dos de los contajes


```{r, message=FALSE, echo=TRUE}
GSE110633_dgeObjnorm
GSE110633_log2countnorm <- cpm(GSE110633_dgeObjnorm, log = TRUE)

b<-GSE110633_dgeObjnorm

b[["samples"]][["samples"]]<-a[["samples"]][["samples"]]

colnames(b$counts)<-b[["samples"]][["samples"]]

c<-GSE110633_log2countnorm

colnames(c)<-a[["samples"]][["samples"]]
```

```{r, message=FALSE, echo=TRUE}
boxplot(c, col = b$samples$cols, las = 2, cex.axis = 0.7,
    main = "Contajes normalizados (log2))")
```

*Esta será nuestra matriz de partida para los análisis siguientes*


## Exploración de los datos: distribución de los contajes

Una vez descartados los genes poco expresados y con los recuentos almacenados en un objeto DGEList, podemos`proceder a realizar algunos gráficos exploratorios para determinar si los datos aparentan buena calidad y/o si presentan algun problema.

Un diagrama de cajas con los datos, normalizados o no, muestra que la distribución de los contajes es muy asimétrica, lo que justifica la decisión de trabajar con los logaritmos de los datos.

La transformación logarítmica puede hacerse directamente pero es mejor usar la función cpm, como se ha hecho, que agrega una pequeña cantidad para evitar tomar logaritmos de cero.


```{r, message=FALSE, echo=TRUE}

GSE110633_rawCounts <- GSE110633_dgeObjnorm$counts

d<-GSE110633_rawCounts


colnames(d)<-a[["samples"]][["samples"]]

```

```{r, message=FALSE, echo=TRUE}
par(mfrow = c(2, 1))

boxplot(d, ylab = "CPM", las = 2, xlab = "", col = a$samples$cols, cex.axis = 0.6,
    main = "Distribución de contajes")

boxplot(c, ylab = "Log2-CPM", las = 2, xlab = "", col = GSE110633_dgeObj$samples$cols,
    cex.axis = 0.6, main = "Distribución de log(contajes)")

abline(h = median(c), col = "blue")
par(mfrow = c(1, 1))

```


## Análisis de similaridad entre las muestras: distancia entre muestras

La función dist permite calcular una matriz de distancias que contiene las comparaciones dos a dos entre todas las muestras. Por defecto se utiliza una distancia euclídea.


```{r, message=FALSE, echo=TRUE}
GSE110633_sampleDists <- dist(t(GSE110633_log2countnorm))
round(GSE110633_sampleDists, 1)

e <- dist(t(c))
```


Las matrices de distancias se pueden visualizar directamente con un heatmap.


```{r, message=FALSE, echo=TRUE}
library(factoextra)
fviz_dist(e)

```

No hay una agrupación clara entre grupos.


## Análisis de similaridad entre las muestras: agrupamiento jerárquico

```{r, message=FALSE, echo=TRUE}
hc <- hclust(e)
plot(hc, labels = colnames(c), main = "Agrpamiento jerárquico de las muestras",
    cex = 0.8)

```

En el gráfico no vemos una distribución cercana de las muestras semejantes.


## Análisis de similaridad entre las muestras: agrupamiento jerárquico

```{r, message=FALSE, echo=TRUE}
col.status <- b$samples$cols
plotMDS(c, col = col.status, main = "Status", cex = 0.7)

```

Seguimos sin distinguir una distribución clara.



```{r, message=FALSE, echo=TRUE}

save(GSE110633_counts.keep, GSE110633_dgeObjnorm,
     file =
       "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE110633/filtr_dgeObjnorm.Rda")

# save(GSE110633_counts.keep, GSE110633_dgeObjnorm, GSE110633_log2countnorm,
     # file =
       # "C:/Users/crist/Documents/TFM/filtr_dgeObjnorm.Rda")

```



Luego haremos el análisis de expresión diferencial.

# GSE110636


## Normalización

```{r, message=FALSE, echo=TRUE}
library(edgeR)
GSE110636_dgeObjnorm <- calcNormFactors(GSE110636_dgeObj)
head(GSE110636_dgeObj$samples, 10)
head(GSE110636_dgeObjnorm$samples, 10)

```


```{r, message=FALSE, echo=TRUE}

save(GSE110636_counts.keep, GSE110636_dgeObjnorm,
     file =
       "C:/Users/Copito/OneDrive/Documentos/Master bioinf y bioest/TFM/datasets/GSE110636/filtr_dgeObjnorm.Rda")

```


## Transformación logarítmica

Las transformaciones anteriores buscan compensar el tamaño distinto de las librerías o la distinta composición de éstas, pero las distribuciones de los contajes en cada muestra son asimétricas.


```{r, message=FALSE, echo=TRUE}
a<-GSE110636_dgeObj


for(i in 1:length(a[["samples"]][["group"]])) {
  a[["samples"]][["samples"]][i]<-paste0(a[["samples"]][["group"]][i], i)
  
  }



b<-GSE110636_dgeObjnorm

b[["samples"]][["samples"]]<-a[["samples"]][["samples"]]

colnames(b$counts)<-b[["samples"]][["samples"]]
```


```{r, message=FALSE, echo=TRUE}
boxplot(b$counts, col = b$samples$cols, las = 2, cex.axis = 0.7,
    main = "Contajes normalizados", ylim = c(0, 10000))
```

Para finalizar el preprocesado se toman logaritmo base dos de los contajes


```{r, message=FALSE, echo=TRUE}
GSE110636_dgeObjnorm
GSE110636_log2countnorm <- cpm(GSE110636_dgeObjnorm, log = TRUE)


c<-GSE110636_log2countnorm

colnames(c)<-a[["samples"]][["samples"]]
```

```{r, message=FALSE, echo=TRUE}
boxplot(c, col = b$samples$cols, las = 2, cex.axis = 0.7,
    main = "Contajes normalizados (log2))")
```

*Esta será nuestra matriz de partida para los análisis siguientes*


## Exploración de los datos: distribución de los contajes




```{r, message=FALSE, echo=TRUE}

GSE110636_rawCounts <- GSE110636_dgeObjnorm$counts

d<-GSE110636_rawCounts


colnames(d)<-a[["samples"]][["samples"]]

```

```{r, message=FALSE, echo=TRUE}
par(mfrow = c(2, 1))

boxplot(d, ylab = "CPM", las = 2, xlab = "", col = a$samples$cols, cex.axis = 0.6,
    main = "Distribución de contajes")

boxplot(c, ylab = "Log2-CPM", las = 2, xlab = "", col = GSE110636_dgeObj$samples$cols,
    cex.axis = 0.6, main = "Distribución de log(contajes)")

abline(h = median(c), col = "blue")
par(mfrow = c(1, 1))

```


## Análisis de similaridad entre las muestras: distancia entre muestras

La función dist permite calcular una matriz de distancias que contiene las comparaciones dos a dos entre todas las muestras. Por defecto se utiliza una distancia euclídea.


```{r, message=FALSE, echo=TRUE}
GSE110636_sampleDists <- dist(t(GSE110636_log2countnorm))
round(GSE110636_sampleDists, 1)

e <- dist(t(c))
```


Las matrices de distancias se pueden visualizar directamente con un heatmap.


```{r, message=FALSE, echo=TRUE}
library(factoextra)
fviz_dist(e)

```

No hay una agrupación clara entre grupos.


## Análisis de similaridad entre las muestras: agrupamiento jerárquico

```{r, message=FALSE, echo=TRUE}
hc <- hclust(e)
plot(hc, labels = colnames(c), main = "Agrpamiento jerárquico de las muestras",
    cex = 0.8)

```

En el gráfico no vemos una distribución cercana de las muestras semejantes. Los catro de la derecha se parecen menos al resto, pero no parece tener realción con nada.


## Análisis de similaridad entre las muestras: agrupamiento jerárquico

```{r, message=FALSE, echo=TRUE}
col.status <- b$samples$cols
plotMDS(c, col = col.status, main = "Status", cex = 0.7)

```

Seguimos sin distinguir una distribución clara.

Luego haremos el análisis de expresión diferencial.






